{"mappings":"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","sources":["node_modules/cubing/dist/esm/redi_cube-FYRLEZZH.js","node_modules/cubing/src/cubing/vendor/xyzzy/redi_cube.js"],"sourcesContent":["\"use strict\";\nimport {\n  randomUIntBelowFactory\n} from \"./chunk-43SBQEWR.js\";\nimport {\n  Alg\n} from \"./chunk-DO7GZAW4.js\";\nimport \"./chunk-MGJA5U5O.js\";\n\n// src/cubing/vendor/xyzzy/redi_cube.js\nfunction factorial(n) {\n  if (n < 2)\n    return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++)\n    f *= i;\n  return f;\n}\nfunction C(n, k) {\n  if (k < 0 || k > n)\n    return 0;\n  if (k === 0 || k === n)\n    return 1;\n  let c = 1;\n  for (let i = 0; i < k; i++) {\n    c = c * (n - i) / (i + 1) | 0;\n  }\n  return c;\n}\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\nfunction index_to_permutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1);\n  for (let i = 0; i < n; i++) {\n    perm[i] = ind / f | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      perm[j] += +(perm[j] >= perm[i]);\n    }\n  }\n  return perm;\n}\nfunction permutation_parity(A) {\n  let n = A.length;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i; j < n; j++) {\n      if (A[i] > A[j])\n        parity ^= 1;\n    }\n  }\n  return parity;\n}\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = ind / f | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i])\n        perm[j]++;\n      else\n        parity ^= 1;\n    }\n  }\n  if (parity === 1)\n    [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\nfunction comb_to_index(l) {\n  let bits = l.length;\n  let ones = 0;\n  for (let i = 0; i < bits; i++)\n    ones += +(l[i] === 1);\n  let zeros = bits - ones;\n  if (zeros === 0 || ones === 0 || bits === 1)\n    return 0;\n  let b = C(bits - 1, ones);\n  let ind = 0;\n  for (let i = 0; zeros > 0 && ones > 0 && bits > 1; i++) {\n    bits--;\n    if (l[i] === 0) {\n      b = b * --zeros / bits;\n    } else {\n      ind += b;\n      b = b * ones-- / bits;\n    }\n  }\n  return ind;\n}\nfunction index_to_comb(ind, ones, bits) {\n  let zeros = bits - ones;\n  let b = C(bits - 1, ones);\n  let l = [];\n  let n = bits - 1;\n  for (let i = 0; i < n; i++) {\n    bits--;\n    if (ind < b) {\n      l.push(0);\n      b = b * --zeros / bits;\n    } else {\n      l.push(1);\n      ind -= b;\n      b = b * ones-- / bits;\n    }\n  }\n  l.push(ones);\n  return l;\n}\nfunction compose(A, B) {\n  let C2 = [];\n  for (let i = 0; i < B.length; i++)\n    C2[i] = A[B[i]];\n  return C2;\n}\nfunction permutation_from_cycle(cycle, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++)\n    perm[i] = i;\n  for (let i = 0; i < cycle.length; i++) {\n    perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n  }\n  return perm;\n}\nfunction unsparsify_list(d, n) {\n  let l = Array(n).fill(0);\n  for (let k in d)\n    l[k] = d[k];\n  return l;\n}\nfunction compose_state(state1, state2) {\n  let o = Array(8).fill(0);\n  for (let i = 0; i < 8; i++)\n    o[i] = (state1[1][i] + state2[1][i]) % 3;\n  return [compose(state1[0], state2[0]), o];\n}\nvar move_UL = [\n  permutation_from_cycle([0, 1, 4], 12),\n  unsparsify_list({ 0: 2 }, 8)\n];\nvar move_U = [\n  permutation_from_cycle([1, 2, 5], 12),\n  unsparsify_list({ 1: 2 }, 8)\n];\nvar move_UR = [\n  permutation_from_cycle([2, 3, 6], 12),\n  unsparsify_list({ 2: 2 }, 8)\n];\nvar move_F = [\n  permutation_from_cycle([3, 0, 7], 12),\n  unsparsify_list({ 3: 2 }, 8)\n];\nvar move_L = [\n  permutation_from_cycle([9, 8, 4], 12),\n  unsparsify_list({ 4: 2 }, 8)\n];\nvar move_B = [\n  permutation_from_cycle([10, 9, 5], 12),\n  unsparsify_list({ 5: 2 }, 8)\n];\nvar move_R = [\n  permutation_from_cycle([11, 10, 6], 12),\n  unsparsify_list({ 6: 2 }, 8)\n];\nvar move_D = [\n  permutation_from_cycle([8, 11, 7], 12),\n  unsparsify_list({ 7: 2 }, 8)\n];\nvar solved = [index_to_permutation(0, 12), Array(8).fill(0)];\nvar moves = [move_UL, move_U, move_UR, move_F, move_L, move_B, move_R, move_D];\nvar move_names = [\"UL\", \"U\", \"UR\", \"F\", \"L\", \"B\", \"R\", \"D\"];\nvar tetrad = [0, 1, 0, 1, 1, 0, 1, 0];\nfunction stringify_move_sequence(move_sequence) {\n  let suffixes = [\"0\", \"\", \"'\"];\n  let s = move_sequence.map(([m, r]) => move_names[m] + suffixes[r]);\n  return s.join(\" \");\n}\nfunction generate_random_state(randomUintBelow2) {\n  let p = index_to_evenpermutation(Math.floor(randomUintBelow2(factorial(12)) / 2), 12);\n  let o = Array(8);\n  for (let i = 0; i < 8; i++)\n    o[i] = randomUintBelow2(3);\n  return [p, o];\n}\nfunction generate_random_state_scramble(randomUintBelow2) {\n  return solve(generate_random_state(randomUintBelow2));\n}\nfunction solve(state) {\n  let phase1_indices = index_phase1(state);\n  let phase1_mtables = [\n    generate_phase1_edge_mtable(),\n    generate_phase1_separate_mtable()\n  ];\n  let phase1_ptables = [\n    generate_phase1_edge_ptable(),\n    generate_phase1_separate_ptable()\n  ];\n  let phase2_mtables = [\n    generate_phase2_edge_mtable(),\n    generate_phase2_corner_mtable()\n  ];\n  let phase2_ptables = [\n    generate_phase2_edge_ptable(),\n    generate_phase1_corner_ptable()\n  ];\n  let phase1gen = ida_solve_gen(phase1_indices, phase1_mtables, phase1_ptables);\n  let best = void 0;\n  let intermediate_states = /* @__PURE__ */ new Set();\n  let start_time = +new Date();\n  for (let i = 0; i < 25; i++) {\n    let { value: sol1, done } = phase1gen.next();\n    let new_state = state;\n    for (let [m, r] of sol1) {\n      for (let i2 = 0; i2 < r; i2++)\n        new_state = compose_state(new_state, moves[m]);\n    }\n    if (intermediate_states.has(new_state.toString())) {\n      continue;\n    } else\n      intermediate_states.add(new_state.toString());\n    let edge_ind = evenpermutation_to_index(new_state[0].slice(0, 8));\n    let corner_ind = 0;\n    for (let i2 = 0; i2 < 4; i2++)\n      corner_ind += new_state[1][i2] * 3 ** i2;\n    let phase2_indices = [edge_ind, corner_ind];\n    let moves_left = best ? best.length - sol1.length - 1 : 999999;\n    let sol2 = ida_solve(phase2_indices, phase2_mtables, phase2_ptables, moves_left);\n    if (sol2 === void 0) {\n      continue;\n    }\n    if (best === void 0 || best.length > sol1.length + sol2.length) {\n      best = sol1.concat(sol2);\n    }\n    if (new Date() - start_time > 300)\n      break;\n  }\n  return best;\n}\nfunction index_phase1(state) {\n  let edge_ind = 0;\n  for (let i = 0; i < 4; i++)\n    edge_ind += state[0].indexOf(i + 8) * 12 ** i;\n  let corner_ind = 0;\n  for (let i = 0; i < 4; i++)\n    corner_ind += state[1][i + 4] * 3 ** i;\n  let filtered = state[0].map((x) => Math.max(-1, x - 8));\n  let separate_ind = comb_to_index(filtered.map((x) => +(x >= 0))) * 2 + permutation_parity(filtered.filter((x) => x >= 0));\n  return [edge_ind, corner_ind + 81 * separate_ind];\n}\nvar tables = {};\nfunction generate_phase1_corner_mtable() {\n  if (tables.phase1cm)\n    return tables.phase1cm;\n  let mtable = [];\n  for (let i = 0; i < 81; i++) {\n    mtable[i] = Array(8);\n    let o = [\n      i % 3,\n      Math.floor(i / 3) % 3,\n      Math.floor(i / 9) % 3,\n      Math.floor(i / 27)\n    ];\n    mtable[i][0] = mtable[i][1] = mtable[i][2] = mtable[i][3] = i;\n    for (let j = 0; j < 4; j++) {\n      o[j] = (o[j] + 2) % 3;\n      mtable[i][4 + j] = o[0] + o[1] * 3 + o[2] * 9 + o[3] * 27;\n      o[j] = (o[j] + 1) % 3;\n    }\n  }\n  return tables.phase1cm = mtable;\n}\nfunction generate_phase1_corner_ptable() {\n  if (tables.phase1cp)\n    return tables.phase1cp;\n  let ptable = Array(81);\n  for (let i = 0; i < 81; i++) {\n    let o = [\n      i % 3,\n      Math.floor(i / 3) % 3,\n      Math.floor(i / 9) % 3,\n      Math.floor(i / 27)\n    ];\n    ptable[i] = (o[0] !== 0) + (o[1] !== 0) + (o[2] !== 0) + (o[3] !== 0);\n  }\n  return tables.phase1cp = ptable;\n}\nfunction generate_phase1_edge_mtable() {\n  if (tables.phase1em)\n    return tables.phase1em;\n  let mtable_single = [];\n  for (let i = 0; i < 12; i++) {\n    mtable_single[i] = [];\n    for (let m = 0; m < 8; m++) {\n      mtable_single[i][m] = moves[m][0].indexOf(i);\n    }\n  }\n  let mtable = Array(12 ** 4);\n  for (let i = 0; i < 12 ** 4; i++) {\n    mtable[i] = Array(8);\n    for (let m = 0; m < 8; m++) {\n      let I = 0;\n      for (let j = 0; j < 4; j++) {\n        I += mtable_single[Math.floor(i / 12 ** j) % 12][m] * 12 ** j;\n      }\n      mtable[i][m] = I;\n    }\n  }\n  return tables.phase1em = mtable;\n}\nfunction generate_phase1_edge_ptable() {\n  if (tables.phase1ep)\n    return tables.phase1ep;\n  return tables.phase1ep = bfs(generate_phase1_edge_mtable(), [\n    8 + 12 * (9 + 12 * (10 + 12 * 11))\n  ]);\n}\nfunction generate_phase1_separate_mtable() {\n  if (tables.phase1sm)\n    return tables.phase1sm;\n  const C12_4 = C(12, 4);\n  let mtable_c = [];\n  for (let i = 0; i < C12_4; i++) {\n    mtable_c[i] = [];\n    let comb = index_to_comb(i, 4, 12), perm = [];\n    for (let j = 0, k = 0; j < 12; j++) {\n      if (comb[j] === 0)\n        perm[j] = -1;\n      else\n        perm[j] = k++;\n    }\n    for (let m = 0; m < 8; m++) {\n      let new_perm = compose(perm, moves[m][0]);\n      let new_comb = compose(comb, moves[m][0]);\n      let parity = permutation_parity(new_perm.filter((x) => x >= 0));\n      mtable_c[i][m] = comb_to_index(new_comb) * 2 + parity;\n    }\n  }\n  let mtable_co = generate_phase1_corner_mtable();\n  let mtable = [];\n  for (let j = 0; j < C12_4; j++) {\n    for (let i = 0; i < 81; i++) {\n      let m0 = mtable[i + 81 * (2 * j)] = [];\n      let m1 = mtable[i + 81 * (2 * j + 1)] = [];\n      for (let m = 0; m < 8; m++) {\n        m0[m] = mtable_co[i][m] + 81 * mtable_c[j][m];\n        m1[m] = mtable_co[i][m] + 81 * (mtable_c[j][m] ^ 1);\n      }\n    }\n  }\n  return tables.phase1sm = mtable;\n}\nfunction generate_phase1_separate_ptable() {\n  if (tables.phase1sp)\n    return tables.phase1sp;\n  return tables.phase1sp = bfs(generate_phase1_separate_mtable(), [0]);\n}\nfunction generate_phase2_corner_mtable() {\n  if (tables.phase2cm)\n    return tables.phase2cm;\n  let phase1_mtable = generate_phase1_corner_mtable();\n  let mtable = Array(81);\n  for (let i = 0; i < 81; i++) {\n    mtable[i] = phase1_mtable[i].slice(4, 8);\n  }\n  return tables.phase2cm = mtable;\n}\nfunction generate_phase2_edge_mtable() {\n  if (tables.phase2em)\n    return tables.phase2em;\n  const n = 8;\n  const HALFFACT8 = factorial(n) / 2;\n  let mtable = Array(HALFFACT8);\n  let perm = [0, 1, 2, 3, 4, 5, 6, 7];\n  for (let i = 0; i < HALFFACT8; i++) {\n    mtable[i] = Array(4);\n    for (let m = 0; m < 4; m++) {\n      let new_perm = compose(perm, moves[m][0].slice(0, 8));\n      mtable[i][m] = evenpermutation_to_index(new_perm);\n    }\n    if (i === HALFFACT8 - 1)\n      break;\n    let parity = 0;\n    do {\n      for (let k = n - 2; k >= 0; k--) {\n        if (perm[k] > perm[k + 1])\n          continue;\n        let l = k + 1;\n        for (let L = l; L < n; L++)\n          if (perm[L] > perm[k])\n            l = L;\n        [perm[k], perm[l]] = [perm[l], perm[k]];\n        parity ^= 1;\n        for (let j = 0; k + 1 + j < n - 1 - j; j++, parity ^= 1) {\n          [perm[k + 1 + j], perm[n - 1 - j]] = [\n            perm[n - 1 - j],\n            perm[k + 1 + j]\n          ];\n        }\n        break;\n      }\n    } while (parity !== 0);\n  }\n  return tables.phase2em = mtable;\n}\nfunction generate_phase2_edge_ptable() {\n  if (tables.phase2ep)\n    return tables.phase2ep;\n  return tables.phase2ep = bfs(generate_phase2_edge_mtable(), [0]);\n}\nfunction bfs(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  let queue = goal_states.slice(), new_queue = [];\n  let depth = 0;\n  while (queue.length > 0) {\n    new_queue.length = 0;\n    for (let state of queue) {\n      if (ptable[state] !== -1)\n        continue;\n      ptable[state] = depth;\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        while (new_state != state) {\n          new_queue.push(new_state);\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    [queue, new_queue] = [new_queue, queue];\n    depth += 1;\n  }\n  return ptable;\n}\nfunction ida_solve(indices, mtables, ptables, max_bound) {\n  max_bound = max_bound || 999999;\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= max_bound) {\n    let path = ida_search(indices, mtables, ptables, bound, -1);\n    if (path !== void 0)\n      return path;\n    bound++;\n  }\n}\nfunction ida_search(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound)\n    return;\n  if (bound === 0)\n    return [];\n  if (heuristic === 0 && bound === 1)\n    return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last)\n      continue;\n    if (m < last && tetrad[m] == tetrad[last])\n      continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath = ida_search(new_indices, mtables, ptables, bound - 1, m);\n      if (subpath !== void 0)\n        return [[m, r]].concat(subpath);\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n  return;\n}\nfunction* ida_solve_gen(indices, mtables, ptables) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (true) {\n    yield* ida_search_gen(indices, mtables, ptables, bound, -1);\n    bound++;\n  }\n}\nfunction* ida_search_gen(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound)\n    return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1)\n    return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last)\n      continue;\n    if (m < last && tetrad[m] == tetrad[last])\n      continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = ida_search_gen(new_indices, mtables, ptables, bound - 1, m);\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done)\n          break;\n        yield [[m, r]].concat(subpath);\n      }\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n}\nvar randomUintBelow = randomUIntBelowFactory();\nasync function getRandomRediCubeScramble() {\n  return new Alg(stringify_move_sequence(generate_random_state_scramble(await randomUintBelow)));\n}\n\"use strict\";\nexport {\n  getRandomRediCubeScramble\n};\n//# sourceMappingURL=redi_cube-FYRLEZZH.js.map\n","/* eslint-disable */\n/* Redi cube scramble generator */\n// From https://torchlight.github.io/rediscrambler.js\n// Added to `cubing.js` under the GPL license by permission from the author (@torchlight/xyzzy).\n\n\"use strict\";\n\nimport { Alg } from \"../../alg\";\nimport { randomUIntBelowFactory } from \"../random-uint-below\";\n\nfunction counter(A) {\n  let counts = [];\n  for (let a of A) counts[a] = (counts[a] || 0) + 1;\n  return counts;\n}\n\n/* Combinatoric functions */\n\nfunction factorial(n) {\n  if (n < 2) return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++) f *= i;\n  return f;\n}\n\nfunction C(n, k) {\n  if (k < 0 || k > n) return 0;\n  if (k === 0 || k === n) return 1;\n  let c = 1;\n  for (let i = 0; i < k; i++) {\n    c = ((c * (n - i)) / (i + 1)) | 0;\n  }\n  return c;\n}\n\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    // invariant: f == factorial(n)\n    // also, perm stores meaningful values up to perm[n]\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\n\nfunction index_to_permutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1);\n  for (let i = 0; i < n; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  // could probably use some kind of binary tree to make this linearithmic, but I am hella lazy.\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      perm[j] += +(perm[j] >= perm[i]);\n    }\n  }\n  return perm;\n}\n\nfunction permutation_parity(A) {\n  let n = A.length;\n  let parity = 0;\n  // again, there is a linearithmic algorithm to count inversions, but >lazy\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i; j < n; j++) {\n      if (A[i] > A[j]) parity ^= 1;\n    }\n  }\n  return parity;\n}\n\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i]) perm[j]++;\n      else parity ^= 1;\n    }\n  }\n  if (parity === 1) [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\n\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\n\nfunction comb_to_index(l) {\n  let bits = l.length;\n  let ones = 0;\n  for (let i = 0; i < bits; i++) ones += +(l[i] === 1);\n  let zeros = bits - ones;\n  if (zeros === 0 || ones === 0 || bits === 1) return 0;\n  let b = C(bits - 1, ones);\n  let ind = 0;\n  for (let i = 0; zeros > 0 && ones > 0 && bits > 1; i++) {\n    bits--;\n    if (l[i] === 0) {\n      b = (b * --zeros) / bits;\n    } // l[i] === 1\n    else {\n      ind += b;\n      b = (b * ones--) / bits;\n    }\n  }\n  return ind;\n}\n\nfunction index_to_comb(ind, ones, bits) {\n  let zeros = bits - ones;\n  let b = C(bits - 1, ones);\n  let l = [];\n  let n = bits - 1;\n  for (let i = 0; i < n; i++) {\n    bits--;\n    if (ind < b) {\n      l.push(0);\n      b = (b * --zeros) / bits;\n    } else {\n      l.push(1);\n      ind -= b;\n      b = (b * ones--) / bits;\n    }\n  }\n  l.push(ones);\n  return l;\n}\n\nfunction compose(A, B) {\n  let C = [];\n  for (let i = 0; i < B.length; i++) C[i] = A[B[i]];\n  return C;\n}\n\nfunction permutation_from_cycle(cycle, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++) perm[i] = i;\n  for (let i = 0; i < cycle.length; i++) {\n    perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n  }\n  return perm;\n}\n\nfunction unsparsify_list(d, n) {\n  let l = Array(n).fill(0);\n  for (let k in d) l[k] = d[k];\n  return l;\n}\n\nfunction compose_state(state1, state2) {\n  let o = Array(8).fill(0);\n  for (let i = 0; i < 8; i++) o[i] = (state1[1][i] + state2[1][i]) % 3;\n  return [compose(state1[0], state2[0]), o];\n}\n\nlet move_UL = [\n  permutation_from_cycle([0, 1, 4], 12),\n  unsparsify_list({ 0: 2 }, 8),\n];\nlet move_U = [\n  permutation_from_cycle([1, 2, 5], 12),\n  unsparsify_list({ 1: 2 }, 8),\n];\nlet move_UR = [\n  permutation_from_cycle([2, 3, 6], 12),\n  unsparsify_list({ 2: 2 }, 8),\n];\nlet move_F = [\n  permutation_from_cycle([3, 0, 7], 12),\n  unsparsify_list({ 3: 2 }, 8),\n];\nlet move_L = [\n  permutation_from_cycle([9, 8, 4], 12),\n  unsparsify_list({ 4: 2 }, 8),\n];\nlet move_B = [\n  permutation_from_cycle([10, 9, 5], 12),\n  unsparsify_list({ 5: 2 }, 8),\n];\nlet move_R = [\n  permutation_from_cycle([11, 10, 6], 12),\n  unsparsify_list({ 6: 2 }, 8),\n];\nlet move_D = [\n  permutation_from_cycle([8, 11, 7], 12),\n  unsparsify_list({ 7: 2 }, 8),\n];\n\nlet solved = [index_to_permutation(0, 12), Array(8).fill(0)];\n\nlet moves = [move_UL, move_U, move_UR, move_F, move_L, move_B, move_R, move_D];\nlet move_names = [\"UL\", \"U\", \"UR\", \"F\", \"L\", \"B\", \"R\", \"D\"];\nlet tetrad = [0, 1, 0, 1, 1, 0, 1, 0];\n\nfunction apply_move_sequence(state, move_sequence) {\n  for (let [m, r] of move_sequence) {\n    for (let i = 0; i < r; i++) state = compose_state(state, moves[m]);\n  }\n  return state;\n}\n\nfunction stringify_move_sequence(move_sequence) {\n  let suffixes = [\"0\", \"\", \"'\"];\n  let s = move_sequence.map(([m, r]) => move_names[m] + suffixes[r]);\n  return s.join(\" \");\n}\n\nfunction print_move_sequence(move_sequence) {\n  console.log(stringify_move_sequence(move_sequence));\n}\n\nfunction generate_random_state(randomUintBelow) {\n  let p = index_to_evenpermutation(\n    Math.floor(randomUintBelow(factorial(12)) / 2),\n    12,\n  );\n  let o = Array(8);\n  for (let i = 0; i < 8; i++) o[i] = randomUintBelow(3);\n  return [p, o];\n}\n\nfunction generate_random_state_scramble(randomUintBelow) {\n  return solve(generate_random_state(randomUintBelow));\n}\n\nfunction generate_scramble_sequence() {\n  return stringify_move_sequence(generate_random_state_scramble());\n}\n\nfunction solve(state) {\n  let phase1_indices = index_phase1(state);\n  let phase1_mtables = [\n    generate_phase1_edge_mtable(),\n    generate_phase1_separate_mtable(),\n  ];\n  let phase1_ptables = [\n    generate_phase1_edge_ptable(),\n    generate_phase1_separate_ptable(),\n  ];\n  let phase2_mtables = [\n    generate_phase2_edge_mtable(),\n    generate_phase2_corner_mtable(),\n  ];\n  let phase2_ptables = [\n    generate_phase2_edge_ptable(),\n    generate_phase1_corner_ptable(),\n  ];\n\n  let phase1gen = ida_solve_gen(phase1_indices, phase1_mtables, phase1_ptables);\n  let best = undefined;\n  let intermediate_states = new Set();\n  let start_time = +new Date();\n  for (let i = 0; i < 25; i++) {\n    let { value: sol1, done } = phase1gen.next();\n    let new_state = state;\n    for (let [m, r] of sol1) {\n      for (let i = 0; i < r; i++)\n        new_state = compose_state(new_state, moves[m]);\n    }\n    if (intermediate_states.has(new_state.toString())) {\n      // console.log(\"skip\");\n      continue;\n    } else intermediate_states.add(new_state.toString());\n    let edge_ind = evenpermutation_to_index(new_state[0].slice(0, 8));\n    let corner_ind = 0;\n    for (let i = 0; i < 4; i++) corner_ind += new_state[1][i] * 3 ** i;\n    let phase2_indices = [edge_ind, corner_ind];\n    //let sol2 = [];\n    let moves_left = best ? best.length - sol1.length - 1 : 999999;\n    let sol2 = ida_solve(\n      phase2_indices,\n      phase2_mtables,\n      phase2_ptables,\n      moves_left,\n    );\n    if (sol2 === undefined) {\n      // console.log(\"prune\");\n      continue;\n    }\n    // console.log(\n    //   `to ${new_state} in ${sol1.length} moves; total move count ${\n    //     sol1.length + sol2.length\n    //   }`,\n    // );\n    if (best === undefined || best.length > sol1.length + sol2.length) {\n      best = sol1.concat(sol2);\n    }\n    // bail if we've spent too much time\n    if (new Date() - start_time > 300) break;\n  }\n  return best;\n}\n\nfunction index_phase1(state) {\n  let edge_ind = 0;\n  for (let i = 0; i < 4; i++) edge_ind += state[0].indexOf(i + 8) * 12 ** i;\n  let corner_ind = 0;\n  for (let i = 0; i < 4; i++) corner_ind += state[1][i + 4] * 3 ** i;\n  let filtered = state[0].map((x) => Math.max(-1, x - 8));\n  let separate_ind =\n    comb_to_index(filtered.map((x) => +(x >= 0))) * 2 +\n    permutation_parity(filtered.filter((x) => x >= 0));\n  return [edge_ind, corner_ind + 81 * separate_ind];\n}\n\nlet tables = {};\n\nfunction generate_phase1_corner_mtable() {\n  if (tables.phase1cm) return tables.phase1cm;\n  let mtable = [];\n  for (let i = 0; i < 81; i++) {\n    mtable[i] = Array(8);\n    let o = [\n      i % 3,\n      Math.floor(i / 3) % 3,\n      Math.floor(i / 9) % 3,\n      Math.floor(i / 27),\n    ];\n    mtable[i][0] = mtable[i][1] = mtable[i][2] = mtable[i][3] = i;\n    for (let j = 0; j < 4; j++) {\n      o[j] = (o[j] + 2) % 3;\n      mtable[i][4 + j] = o[0] + o[1] * 3 + o[2] * 9 + o[3] * 27;\n      o[j] = (o[j] + 1) % 3;\n    }\n  }\n  return (tables.phase1cm = mtable);\n}\n\nfunction generate_phase1_corner_ptable() {\n  if (tables.phase1cp) return tables.phase1cp;\n  let ptable = Array(81);\n  for (let i = 0; i < 81; i++) {\n    let o = [\n      i % 3,\n      Math.floor(i / 3) % 3,\n      Math.floor(i / 9) % 3,\n      Math.floor(i / 27),\n    ];\n    ptable[i] = (o[0] !== 0) + (o[1] !== 0) + (o[2] !== 0) + (o[3] !== 0);\n  }\n  return (tables.phase1cp = ptable);\n}\n\nfunction generate_phase1_edge_mtable() {\n  if (tables.phase1em) return tables.phase1em;\n  let mtable_single = [];\n  for (let i = 0; i < 12; i++) {\n    mtable_single[i] = [];\n    for (let m = 0; m < 8; m++) {\n      mtable_single[i][m] = moves[m][0].indexOf(i);\n    }\n  }\n  let mtable = Array(12 ** 4);\n  for (let i = 0; i < 12 ** 4; i++) {\n    mtable[i] = Array(8);\n    for (let m = 0; m < 8; m++) {\n      let I = 0;\n      for (let j = 0; j < 4; j++) {\n        I += mtable_single[Math.floor(i / 12 ** j) % 12][m] * 12 ** j;\n      }\n      mtable[i][m] = I;\n    }\n  }\n  return (tables.phase1em = mtable);\n}\n\nfunction generate_phase1_edge_ptable() {\n  if (tables.phase1ep) return tables.phase1ep;\n  return (tables.phase1ep = bfs(generate_phase1_edge_mtable(), [\n    8 + 12 * (9 + 12 * (10 + 12 * 11)),\n  ]));\n}\n\nfunction generate_phase1_separate_mtable() {\n  if (tables.phase1sm) return tables.phase1sm;\n  const C12_4 = C(12, 4);\n  let mtable_c = [];\n  for (let i = 0; i < C12_4; i++) {\n    mtable_c[i] = [];\n    let comb = index_to_comb(i, 4, 12),\n      perm = [];\n    for (let j = 0, k = 0; j < 12; j++) {\n      if (comb[j] === 0) perm[j] = -1;\n      else perm[j] = k++;\n    }\n    for (let m = 0; m < 8; m++) {\n      let new_perm = compose(perm, moves[m][0]);\n      let new_comb = compose(comb, moves[m][0]);\n      let parity = permutation_parity(new_perm.filter((x) => x >= 0));\n      mtable_c[i][m] = comb_to_index(new_comb) * 2 + parity;\n    }\n  }\n  let mtable_co = generate_phase1_corner_mtable();\n  let mtable = [];\n  for (let j = 0; j < C12_4; j++) {\n    for (let i = 0; i < 81; i++) {\n      let m0 = (mtable[i + 81 * (2 * j)] = []);\n      let m1 = (mtable[i + 81 * (2 * j + 1)] = []);\n      for (let m = 0; m < 8; m++) {\n        m0[m] = mtable_co[i][m] + 81 * mtable_c[j][m];\n        m1[m] = mtable_co[i][m] + 81 * (mtable_c[j][m] ^ 1);\n      }\n    }\n  }\n  return (tables.phase1sm = mtable);\n}\n\nfunction generate_phase1_separate_ptable() {\n  if (tables.phase1sp) return tables.phase1sp;\n  return (tables.phase1sp = bfs(generate_phase1_separate_mtable(), [0]));\n}\n\nfunction generate_phase2_corner_mtable() {\n  if (tables.phase2cm) return tables.phase2cm;\n  let phase1_mtable = generate_phase1_corner_mtable();\n  let mtable = Array(81);\n  for (let i = 0; i < 81; i++) {\n    mtable[i] = phase1_mtable[i].slice(4, 8);\n  }\n  return (tables.phase2cm = mtable);\n}\n\nfunction generate_phase2_edge_mtable() {\n  if (tables.phase2em) return tables.phase2em;\n  const n = 8;\n  const HALFFACT8 = factorial(n) / 2;\n  let mtable = Array(HALFFACT8);\n  let perm = [0, 1, 2, 3, 4, 5, 6, 7];\n  for (let i = 0; i < HALFFACT8; i++) {\n    //perm = index_to_evenpermutation(i, 8);\n    mtable[i] = Array(4);\n    for (let m = 0; m < 4; m++) {\n      let new_perm = compose(perm, moves[m][0].slice(0, 8));\n      mtable[i][m] = evenpermutation_to_index(new_perm);\n    }\n\n    if (i === HALFFACT8 - 1) break;\n    // update perm to lex-next even permutation\n    let parity = 0;\n    do {\n      for (let k = n - 2; k >= 0; k--) {\n        if (perm[k] > perm[k + 1]) continue;\n        let l = k + 1;\n        for (let L = l; L < n; L++) if (perm[L] > perm[k]) l = L;\n        [perm[k], perm[l]] = [perm[l], perm[k]];\n        parity ^= 1;\n        for (let j = 0; k + 1 + j < n - 1 - j; j++, parity ^= 1) {\n          [perm[k + 1 + j], perm[n - 1 - j]] = [\n            perm[n - 1 - j],\n            perm[k + 1 + j],\n          ];\n        }\n        break;\n      }\n    } while (parity !== 0);\n  }\n  return (tables.phase2em = mtable);\n}\n\nfunction generate_phase2_edge_ptable() {\n  if (tables.phase2ep) return tables.phase2ep;\n  return (tables.phase2ep = bfs(generate_phase2_edge_mtable(), [0]));\n}\n\nfunction bfs(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  let queue = goal_states.slice(),\n    new_queue = [];\n  let depth = 0;\n  while (queue.length > 0) {\n    new_queue.length = 0;\n    for (let state of queue) {\n      if (ptable[state] !== -1) continue;\n      ptable[state] = depth;\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        while (new_state != state) {\n          new_queue.push(new_state);\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    [queue, new_queue] = [new_queue, queue];\n    depth += 1;\n  }\n  return ptable;\n}\n\nfunction ida_solve(indices, mtables, ptables, max_bound) {\n  max_bound = max_bound || 999999;\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= max_bound) {\n    let path = ida_search(indices, mtables, ptables, bound, -1);\n    if (path !== undefined) return path;\n    bound++;\n  }\n}\n\nfunction ida_search(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) return [];\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && tetrad[m] == tetrad[last]) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath = ida_search(new_indices, mtables, ptables, bound - 1, m);\n      if (subpath !== undefined) return [[m, r]].concat(subpath);\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n  return;\n}\n\nfunction* ida_solve_gen(indices, mtables, ptables) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (true) {\n    yield* ida_search_gen(indices, mtables, ptables, bound, -1);\n    bound++;\n  }\n}\n\nfunction* ida_search_gen(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && tetrad[m] == tetrad[last]) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = ida_search_gen(\n        new_indices,\n        mtables,\n        ptables,\n        bound - 1,\n        m,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n}\n\nconst randomUintBelow = randomUIntBelowFactory();\nexport async function getRandomRediCubeScramble() {\n  return new Alg(\n    stringify_move_sequence(\n      generate_random_state_scramble(await randomUintBelow),\n    ),\n  );\n}\n"],"names":[],"version":3,"file":"redi_cube-FYRLEZZH.92373db2.js.map"}