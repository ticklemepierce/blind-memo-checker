{"mappings":"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","sources":["node_modules/cubing/src/cubing/vendor/xyzzy/fto-solver.js"],"sourcesContent":["/* eslint-disable */\n/* ftosolver.js - An FTO solver\nversion 0.5.1 (2021-04-20)\n\nCopyright (c) 2016, 2020, 2021\n\nFrom https://gist.github.com/torchlight/9a5c53da09d8e090756a228f4b5f3471\nOriginally MIT licensed, added to `cubing.js` under the GPL license by permission from the author (@torchlight/xyzzy).\n\nCompatibility note:\nThis is targeted at Firefox / Spidermonkey releases from 2019 and onwards. It might not run on older\nJavaScript engines. Recent Chrome / Node releases should also work, but are not tested as much.\n*/\n\nimport { randomUIntBelowFactory } from \"../random-uint-below\";\n\n/* Helper functions */\n\nfunction counter(A) {\n  let counts = [];\n  for (let a of A) counts[a] = (counts[a] || 0) + 1;\n  return counts;\n}\n\n/* Combinatoric functions */\n\nfunction factorial(n) {\n  if (n < 2) return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++) f *= i;\n  return f;\n}\n\nfunction C(n, k) {\n  if (k < 0 || k > n) return 0;\n  if (k === 0 || k === n) return 1;\n  let c = 1;\n  for (let i = 0; i < k; i++) {\n    c = ((c * (n - i)) / (i + 1)) | 0;\n  }\n  return c;\n}\n\nfunction C4(n, k0, k1, k2, k3 = n - k0 - k1 - k2) {\n  return C(n, k0 + k1) * C(k0 + k1, k0) * C(k2 + k3, k2);\n}\n\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    // invariant: f == factorial(n)\n    // also, perm stores meaningful values up to perm[n]\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\n\nfunction index_to_permutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1);\n  for (let i = 0; i < n; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      perm[j] += +(perm[j] >= perm[i]);\n    }\n  }\n  return perm;\n}\n\nfunction permutation_parity(A) {\n  let n = A.length;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i; j < n; j++) {\n      if (A[i] > A[j]) parity ^= 1;\n    }\n  }\n  return parity;\n}\n\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i]) perm[j]++;\n      else parity ^= 1;\n    }\n  }\n  if (parity === 1) [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\n\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\n\nlet [evenpermutation8_to_index, index_to_evenpermutation8] = (() => {\n  let index_in_set_bits = new Int8Array(256 * 8);\n  let look_up_set_bits = new Int8Array(256 * 8);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0, counter = 0; j < 8; j++) {\n      if (((i >>> j) & 1) === 0) {\n        continue;\n      }\n      index_in_set_bits[(j << 8) | i] = counter;\n      look_up_set_bits[(counter << 8) | i] = j;\n      counter++;\n    }\n  }\n\n  function evenpermutation8_to_index(perm) {\n    let unused = 0xff; // track which values in 0..7 haven't been used so far\n    let f = 2520; // = 7!/2\n    let ind = 0;\n    for (let i = 0; i < 6; i++) {\n      let v = perm[i];\n      ind += index_in_set_bits[unused | (v << 8)] * f;\n      unused &= ~(1 << v);\n      f /= 7 - i;\n    }\n    return ind;\n  }\n\n  // note: this is *not* a drop-in replacement for index_to_evenpermutation!\n  function index_to_evenpermutation8(ind, perm) {\n    let unused = 0xff;\n    let f = 2520; // = 7!/2\n    let parity = 0;\n    for (let i = 0; i < 6; i++) {\n      let a = (ind / f) | 0;\n      ind -= a * f;\n      parity ^= a & 1;\n      let v = look_up_set_bits[unused | (a << 8)];\n      perm[i] = v;\n      unused &= ~(1 << v);\n      f /= 7 - i;\n    }\n    // the last two elements are uniquely determined by the others\n    perm[6] = look_up_set_bits[unused | (parity << 8)];\n    perm[7] = look_up_set_bits[unused | ((parity ^ 1) << 8)];\n    return perm;\n  }\n\n  return [evenpermutation8_to_index, index_to_evenpermutation8];\n})();\n\nfunction random_permutation(n, randomUintBelow) {\n  let p = [0];\n  for (let i = 1; i < n; i++) {\n    let r = randomUintBelow(i + 1);\n    p[i] = p[r];\n    p[r] = i;\n  }\n  return p;\n}\n\nfunction random_even_permutation(n, randomUintBelow) {\n  let p = random_permutation(n, randomUintBelow);\n  if (permutation_parity(p) === 1) {\n    [p[0], p[1]] = [p[1], p[0]];\n  }\n  return p;\n}\n\nfunction comb_to_index(l) {\n  let bits = l.length;\n  let ones = 0;\n  for (let i = 0; i < bits; i++) ones += +(l[i] === 1);\n  let zeros = bits - ones;\n  if (zeros === 0 || ones === 0 || bits === 1) return 0;\n  let b = C(bits - 1, ones);\n  let ind = 0;\n  for (let i = 0; zeros > 0 && ones > 0 && bits > 1; i++) {\n    bits--;\n    if (l[i] === 0) {\n      b = (b * --zeros) / bits;\n    } // l[i] === 1\n    else {\n      ind += b;\n      b = (b * ones--) / bits;\n    }\n  }\n  return ind;\n}\n\nfunction index_to_comb(ind, ones, bits) {\n  let zeros = bits - ones;\n  let b = C(bits - 1, ones);\n  let l = [];\n  let n = bits - 1;\n  for (let i = 0; i < n; i++) {\n    bits--;\n    if (ind < b) {\n      l.push(0);\n      b = (b * --zeros) / bits;\n    } else {\n      l.push(1);\n      ind -= b;\n      b = (b * ones--) / bits;\n    }\n  }\n  l.push(ones);\n  return l;\n}\n\n// this is \"incorrect\" for n=0 but that's out of scope\nfunction ctz(n) {\n  n |= 0;\n  return 31 - Math.clz32(n ^ (n - 1));\n}\n\nlet comb_lookup_tables = {};\nfunction generate_comb_lookup_tables(n, k) {\n  // 2 <= n <= 28, 0 <= k <= n\n  n |= 0;\n  k |= 0;\n  let key = n + \" \" + k;\n  if (comb_lookup_tables[key]) {\n    return comb_lookup_tables[key];\n  }\n  let total = C(n, k);\n  let index_to_comb_table = new Uint32Array(total);\n  let comb_to_index_table = new Uint32Array(1 << n).fill(-1);\n  for (let i = 0, c = (1 << k) - 1; i < total; i++) {\n    index_to_comb_table[i] = c;\n    comb_to_index_table[c] = i;\n    let t = c | (c - 1);\n    c = (t + 1) | (((~t & -~t) - 1) >> (ctz(c) + 1));\n  }\n  return (comb_lookup_tables[key] = [index_to_comb_table, comb_to_index_table]);\n}\n\nfunction popcount(n) {\n  n |= 0;\n  let c = 0;\n  while (n !== 0) {\n    n &= n - 1;\n    c++;\n  }\n  return c;\n}\n\nfunction spread_bits(n) {\n  n &= 0xffff;\n  n = (n | (n << 8)) & 0x00ff00ff;\n  n = (n | (n << 4)) & 0x0f0f0f0f;\n  n = (n | (n << 2)) & 0x33333333;\n  n = (n | (n << 1)) & 0x55555555;\n  return n;\n}\n\nfunction interleave_bits(x, y) {\n  return spread_bits(x) | (spread_bits(y) << 1);\n}\n\nlet comb4_lookup_tables = {};\nfunction generate_comb4_lookup_tables(n, k0, k1, k2, k3) {\n  // 3 <= n <= 14\n  // 0 <= k0,k1,k2,k3 <= n\n  // n = k0 + k1 + k2 + k3\n  // WARNING: This does not return the combinations in sorted order.\n  // (but if only two of k0,k1,k2,k3 are nonzero, then they will be sorted)\n  n |= 0;\n  k0 |= 0;\n  k1 |= 0;\n  k2 |= 0;\n  k3 |= 0;\n  if (n !== k0 + k1 + k2 + k3) {\n    throw \"generate_comb4_lookup_tables: invalid parameters\";\n  }\n  let key = [n, k0, k1, k2, k3].join(\" \");\n  if (comb4_lookup_tables[key]) {\n    return comb4_lookup_tables[key];\n  }\n  let [itcl, ctil] = generate_comb_lookup_tables(n, k1 + k3);\n  let [itch, ctih] = generate_comb_lookup_tables(n, k2 + k3);\n  let total = C4(n, k0, k1, k2, k3);\n  let index_to_comb4_table = new Uint32Array(total);\n  let comb4_to_index_table = new Uint32Array(4 ** n).fill(-1);\n  for (let i = 0, index = 0; i < itch.length; i++) {\n    let ch = itch[i];\n    for (let j = 0; j < itcl.length; j++) {\n      let cl = itcl[j];\n      if (popcount(cl & ch) === k3) {\n        let c = interleave_bits(cl, ch);\n        index_to_comb4_table[index] = c;\n        comb4_to_index_table[c] = index;\n        index++;\n      }\n    }\n  }\n  return (comb4_lookup_tables[key] = [\n    index_to_comb4_table,\n    comb4_to_index_table,\n  ]);\n}\n\nfunction compose(A, B) {\n  let C = [];\n  for (let i = 0; i < B.length; i++) C[i] = A[B[i]];\n  return C;\n}\n\nfunction compose3(A, B, C) {\n  let D = [];\n  for (let i = 0; i < C.length; i++) D[i] = A[B[C[i]]];\n  return D;\n}\n\nfunction compose_o(A, B) {\n  let p = compose(A[0], B[0]);\n  let o = [];\n  let n = B[0].length;\n  for (let i = 0; i < n; i++) {\n    o[i] = A[1][B[0][i]] ^ B[1][i];\n  }\n  return [p, o];\n}\n\n/*\nfunction permutation_from_cycle(cycle, n)\n{\n\tlet perm = [];\n\tfor (let i = 0; i < n; i++) {perm[i] = i};\n\tfor (let i = 0; i < cycle.length; i++)\n\t{\n\t\tperm[cycle[i]] = cycle[(i + 1) % cycle.length];\n\t}\n\treturn perm;\n}\n*/\n\nfunction permutation_from_cycles(cycles, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++) {\n    perm[i] = i;\n  }\n  for (let cycle of cycles) {\n    for (let i = 0; i < cycle.length; i++) {\n      perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n    }\n  }\n  return perm;\n}\n\nfunction reduce_permutation(perm, keep) {\n  // perm: a permutation\n  // keep: array of booleans, of the same length as perm\n  let n = perm.length;\n  let count = Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    count[i] = count[i - 1] + keep[i - 1];\n  }\n  let nn = count[n - 1] + keep[n - 1];\n  let reduced = Array(nn);\n  for (let i = 0; i < n; i++) {\n    if (keep[i]) {\n      reduced[count[i]] = count[perm[i]];\n    }\n  }\n  return reduced;\n}\n\nfunction invert_permutation(perm) {\n  let n = perm.length;\n  let inverse = Array(n);\n  for (let i = 0; i < n; i++) {\n    inverse[perm[i]] = i;\n  }\n  return inverse;\n}\n\nfunction gcd(a, b) {\n  while (a && b) {\n    [a, b] = [b % a, a];\n  }\n  return Math.abs(a + b);\n}\n\nfunction lcm(a, b) {\n  return (a * b) / gcd(a, b);\n}\n\nfunction permutation_order(perm) {\n  let order = 1;\n  let n = perm.length;\n  let visited = Array(n).fill(false);\n  let i = -1;\n  while (true) {\n    i = visited.indexOf(false, i + 1);\n    if (i === -1) {\n      break;\n    }\n    let cycle_length = 0;\n    let j = i;\n    while (!visited[j]) {\n      visited[j] = true;\n      j = perm[j];\n      cycle_length++;\n    }\n    //console.log(cycle_length);\n    order = lcm(order, cycle_length);\n  }\n  return order;\n}\n\n/*\nFacelet layout:\n\t\t\t\tU\t\t\t\t\t\t\t\t\tB\n\t\t8\t7\t6\t5\t4\t\t\t\t\t67\t68\t69\t70\t71\n\t44\t\t3\t2\t1\t\t49\t\t\t22\t\t64\t65\t66\t\t35\n\t43\t39\t\t0\t\t46\t50\t\t\t23\t19\t\t63\t\t30\t34\nL\t42\t38\t36\t\t45\t47\t51\tR\tBR\t24\t20\t18\t\t27\t29\t33\tBL\n\t41\t37\t\t9\t\t48\t52\t\t\t25\t21\t\t54\t\t28\t32\n\t40\t\t10\t11\t12\t\t53\t\t\t26\t\t57\t56\t55\t\t31\n\t\t13\t14\t15\t16\t17\t\t\t\t\t62\t61\t60\t59\t58\n\t\t\t\tF\t\t\t\t\t\t\t\t\tD\n\nWe'll be using the facelet permutations as the underlying representation. This specific labelling\ngives us three symmetries that can be written very compactly, and this turns out to be enough to\ngenerate any face move from any other face move.\n\nWhich is nice, because I don't have an FTO and it would be very error prone if I were to write out\nevery move individually.\n\nX = T2\nY = Ro Lo' (I think)\nZ = mirroring so that U swaps with L and F swaps with R\n\nFaces / colours (Lanlan colour scheme):\n0: U (white)\n1: F (red)\n2: BR (grey)\n3: BL (orange)\n4: L (purple)\n5: R (green)\n6: D (yellow)\n7: B (blue)\n*/\n\nlet solved_state = Array(72)\n  .fill()\n  .map((_, i) => (i / 9) | 0);\n\nlet move_U = permutation_from_cycles(\n  [\n    [0, 4, 8],\n    [1, 6, 3],\n    [2, 5, 7],\n    [9, 22, 35],\n    [45, 67, 44],\n    [47, 68, 43],\n    [46, 69, 39],\n    [50, 70, 38],\n    [49, 71, 36],\n  ],\n  72,\n);\nlet move_Ui = compose(move_U, move_U);\n\nlet move_X = Array(72)\n  .fill()\n  .map((_, i) => ((i / 18) | 0) * 18 + ((i + 9) % 18));\nlet move_Y = Array(72)\n  .fill()\n  .map((_, i) => ((i / 36) | 0) * 36 + ((i + 18) % 36));\nlet move_Z = Array(72)\n  .fill()\n  .map((_, i) => (i + 36) % 72);\n\n// Z changes sign, so this is really setting up to U' rather than U\nlet move_L = compose3(move_Z, move_Ui, move_Z);\nlet move_F = compose3(move_X, move_U, move_X);\nlet move_R = compose3(move_X, move_L, move_X);\n\n//let move_BR = compose3(move_Y, move_U, move_Y);\n//let move_BL = compose3(move_Y, move_F, move_Y);\n//let move_B = compose3(move_Y, move_R, move_Y);\n//let move_D = compose3(move_Y, move_L, move_Y);\n\nlet move_Us = permutation_from_cycles(\n  [\n    [10, 24, 30],\n    [11, 23, 34],\n    [12, 19, 33],\n    [42, 48, 64],\n    [41, 52, 65],\n    [37, 51, 66],\n  ],\n  72,\n);\nlet move_Uw = compose(move_U, move_Us);\nlet move_Uwi = compose(move_Uw, move_Uw);\n\nlet move_Lw = compose3(move_Z, move_Uwi, move_Z);\nlet move_Fw = compose3(move_X, move_Uw, move_X);\nlet move_Rw = compose3(move_X, move_Lw, move_X);\n\nlet colour_map = Array(72)\n  .fill()\n  .map((_, i) => (i / 9) | 0);\n\nlet corner_piece_facelets = [\n  [0, 45, 9, 36], // U-F\n  [4, 67, 22, 49], // U-BR\n  [8, 44, 35, 71], // U-BL\n  [13, 58, 31, 40], // F-BL\n  [17, 53, 26, 62], // F-BR\n  [18, 63, 27, 54], // BR-BL\n];\n\nlet edge_piece_facelets = [\n  [1, 46], // U-R\n  [3, 39], // U-L\n  [6, 69], // U-B\n  [10, 37], // F-L\n  [33, 42], // BL-L\n  [12, 48], // F-R  *\n  [15, 60], // F-D  *\n  [24, 51], // BR-R *\n  [19, 64], // BR-B **\n  [28, 55], // BL-D **\n  [30, 66], // BL-B **\n  [21, 57], // BR-D **\n];\n\nlet centreA_piece_facelets = Array(12)\n  .fill()\n  .map((_, i) => ((i / 3) | 0) * 9 + [2, 5, 7][i % 3]);\nlet centreB_piece_facelets = centreA_piece_facelets.map((x) => x + 36);\n\n/*\nfacelet definition sanity test:\nall corner facelets are 0,4,8 mod 9; facelet order is always in U,R,U,R orbits\nall edge facelets are 1,3,6 mod 9; facelet order is always in U,R orbits\nall centre facelets are 2,5,7 mod 9\n\nfunction facelet_sanity_test()\n{\nif (corner_piece_facelets.length !== 6) {console.log('wrong number of corner pieces'); return;}\nif (edge_piece_facelets.length !== 12) {console.log('wrong number of edge pieces'); return;}\nif (!corner_piece_facelets.every(x => {return x.every(y => y % 9 % 4 === 0) && x[0] < 36 && x[2] < 36 && x[1] >= 36 && x[3] >= 36;}))\n{\n\tconsole.log('corner pieces weird');\n\treturn;\n}\nif (!edge_piece_facelets.every(x => {return x.every(y => [1,3,6].indexOf(y % 9) !== -1) && x[0] < 36 && x[1] >= 36;}))\n{\n\tconsole.log('edge pieces weird');\n\treturn;\n}\n}\n\n*/\n\nfunction identify_corner_piece(colourA, colourB) {\n  // return a 2-tuple [p, o] where\n  // p in {0,1,2,3,4,5} is the corner piece's ID and\n  // o in {0,1} is its orientation\n  for (let i = 0; i < 6; i++) {\n    if (\n      colourA === colour_map[corner_piece_facelets[i][0]] &&\n      colourB === colour_map[corner_piece_facelets[i][2]]\n    ) {\n      return [i, 0];\n    } else if (\n      colourA === colour_map[corner_piece_facelets[i][2]] &&\n      colourB === colour_map[corner_piece_facelets[i][0]]\n    ) {\n      return [i, 1];\n    }\n  }\n  throw \"unknown corner piece\";\n}\n\nfunction identify_edge_piece(colourA, colourB) {\n  // return p in {0..11} the edge piece's ID\n  // (edges are not flippable on the FTO)\n  for (let i = 0; i < 12; i++) {\n    if (\n      colourA === colour_map[edge_piece_facelets[i][0]] &&\n      colourB === colour_map[edge_piece_facelets[i][1]]\n    ) {\n      return i;\n    }\n    if (\n      colourB === colour_map[edge_piece_facelets[i][0]] &&\n      colourA === colour_map[edge_piece_facelets[i][1]]\n    ) {\n      return i;\n    }\n  }\n  throw \"unknown edge piece\";\n}\n\nfunction get_corner_piece(facelets, location) {\n  return identify_corner_piece(\n    facelets[corner_piece_facelets[location][0]],\n    facelets[corner_piece_facelets[location][2]],\n  );\n}\n\nfunction get_edge_piece(facelets, location) {\n  return identify_edge_piece(\n    facelets[edge_piece_facelets[location][0]],\n    facelets[edge_piece_facelets[location][1]],\n  );\n}\n\nfunction set_corner_piece(facelets, location, value, orientation) {\n  let indices = corner_piece_facelets[location];\n  let colours = corner_piece_facelets[value].map((x) => colour_map[x]);\n  if (orientation % 2 !== 0) {\n    colours = [colours[2], colours[3], colours[0], colours[1]];\n  }\n  for (let i = 0; i < 4; i++) {\n    facelets[indices[i]] = colours[i];\n  }\n}\n\nfunction set_edge_piece(facelets, location, value) {\n  let indices = edge_piece_facelets[location];\n  let colours = edge_piece_facelets[value].map((x) => colour_map[x]);\n  for (let i = 0; i < 2; i++) {\n    facelets[indices[i]] = colours[i];\n  }\n}\n\nfunction convert_move_to_permutations(move) {\n  let state = move.map((x) => colour_map[x]);\n  //console.log(state);\n  let cp_raw = Array(6)\n    .fill()\n    .map((_, i) => get_corner_piece(state, i));\n  let cp_half = cp_raw.map(([p, o]) => p + 6 * o);\n  let cp = cp_half.concat(cp_half.map((x) => (x + 6) % 12));\n  let ep = Array(12)\n    .fill()\n    .map((_, i) => get_edge_piece(state, i));\n  let ap = Array(12)\n    .fill()\n    .map((_, i) =>\n      centreA_piece_facelets.indexOf(move[centreA_piece_facelets[i]]),\n    );\n  let bp = Array(12)\n    .fill()\n    .map((_, i) =>\n      centreB_piece_facelets.indexOf(move[centreB_piece_facelets[i]]),\n    );\n  return { cp: cp, ep: ep, ap: ap, bp: bp };\n}\n\nlet moves = [\n  move_U,\n  move_L,\n  move_F,\n  move_R,\n  move_Uw,\n  move_Lw,\n  move_Fw,\n  move_Rw,\n];\nlet move_names = [\"U\", \"L\", \"F\", \"R\", \"u\", \"l\", \"f\", \"r\"];\n\nlet move_permutations = moves.map(convert_move_to_permutations);\n\n/*\nlet commute_table = (function () {\n\tlet n = moves.length;\n\tlet t = Array(n);\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tt[i] = Array(n);\n\t\tfor (let j = 0; j < n; j++)\n\t\t{\n\t\t\tlet a = compose(moves[i], moves[j]);\n\t\t\tlet b = compose(moves[j], moves[i]);\n\t\t\tt[i][j] = (a.join(' ') === b.join(' '));\n\t\t}\n\t}\n\treturn t;\n})();\n*/\n\n// generate a random state with the BR-BL corner solved\nfunction random_state(randomUintBelow) {\n  let facelets = Array(72);\n  let cp = random_even_permutation(5, randomUintBelow);\n  cp.push(5);\n  let co = Array(4)\n    .fill()\n    .map((_) => randomUintBelow(2));\n  co.push(co.reduce((x, y) => x ^ y));\n  co.push(0);\n  for (let i = 0; i < 6; i++) {\n    set_corner_piece(facelets, i, cp[i], co[i]);\n  }\n\n  let ep = random_even_permutation(12, randomUintBelow);\n  for (let i = 0; i < 12; i++) {\n    set_edge_piece(facelets, i, ep[i]);\n  }\n\n  let a = random_permutation(12, randomUintBelow).map((x) => (x / 3) | 0);\n  let b = random_permutation(12, randomUintBelow).map((x) => 4 + ((x / 3) | 0));\n  for (let i = 0; i < 12; i++) {\n    facelets[centreA_piece_facelets[i]] = a[i];\n    facelets[centreB_piece_facelets[i]] = b[i];\n  }\n  return facelets;\n}\n\nfunction stringify_move_sequence(move_sequence, no_wide = false) {\n  if (no_wide) {\n    const U = 0,\n      L = 1,\n      F = 2,\n      R = 3,\n      D = 4,\n      BR = 5,\n      B = 6,\n      BL = 7;\n    move_sequence = move_sequence.map((x) => x.slice());\n    let ordering = [U, L, F, R, D, BR, B, BL];\n    let rotations = [\n      [U, R, BR, B, D, BL, L, F],\n      [BL, L, U, B, R, BR, D, F],\n      [BL, D, F, L, R, U, B, BR],\n      [F, D, BR, R, B, U, L, BL],\n    ];\n    rotations = rotations.concat(rotations.map((p) => invert_permutation(p)));\n    for (let i = 0; i < move_sequence.length; i++) {\n      if (move_sequence[i][0] < 4) {\n        // it's already a single-layer turn\n        move_sequence[i][0] = ordering[move_sequence[i][0]];\n      } else {\n        // it's a double-layer turn and we need to Do Stuff\n        let m = ordering[move_sequence[i][0]];\n        let r = move_sequence[i][1];\n        move_sequence[i][0] = m;\n        ordering = compose(r === 1 ? rotations[m ^ 4] : rotations[m], ordering);\n        //console.log(ordering);\n      }\n    }\n  }\n  let names = no_wide ? \"U L F R D BR B BL\".split(\" \") : move_names; // WARNING: this ordering is _not_ the same as the facelet colours\n  let suffixes = [\"0\", \"\", \"'\"];\n  let s = move_sequence.map(([m, r]) => names[m] + suffixes[r]);\n  return s.join(\" \");\n}\n\nfunction print_move_sequence(move_sequence) {\n  console.log(stringify_move_sequence(move_sequence));\n}\n\nfunction apply_move_sequence(state, move_sequence) {\n  for (let [m, r] of move_sequence) {\n    for (let i = 0; i < r; i++) {\n      state = compose(state, moves[m]);\n    }\n  }\n  return state;\n}\n\nfunction invert_move_sequence(move_sequence) {\n  return move_sequence.map(([m, r]) => [m, (3 - r) % 3]).reverse();\n}\n\nfunction simplify_move_sequence(move_sequence, make_noise = false) {\n  if (move_sequence.length === 0) {\n    return [];\n  }\n  let simplified = [];\n  let last_move = undefined;\n  for (let [m, r] of move_sequence) {\n    if (last_move && last_move[0] === m) {\n      // turn of the same face\n      last_move[1] += r;\n      last_move[1] %= 3;\n      if (last_move[1] === 0) {\n        simplified.pop();\n        last_move =\n          simplified.length === 0\n            ? undefined\n            : simplified[simplified.length - 1];\n      }\n    } else if (\n      simplified.length >= 2 &&\n      (last_move[0] ^ m) === 4 &&\n      simplified[simplified.length - 2][0] === m\n    ) {\n      // turn of the opposite face\n      simplified[simplified.length - 2][1] += r;\n      simplified[simplified.length - 2][1] %= 3;\n      if (simplified[simplified.length - 2][1] === 0) {\n        simplified.splice(simplified.length - 2, 1);\n      }\n    } else {\n      last_move = [m, r];\n      simplified.push(last_move);\n    }\n  }\n  if (make_noise && \"\" + move_sequence !== \"\" + simplified) {\n    console.log(`simplified ${move_sequence} to ${simplified}`);\n  }\n  return simplified;\n}\n\nfunction generate_random_state_scramble(randomUintBelow) {\n  return stringify_move_sequence(\n    invert_move_sequence(solve(random_state(randomUintBelow), true)),\n    true,\n  );\n}\n\nfunction generate_multiple_random_state_scrambles(n) {\n  let scrambles = [];\n  for (let i = 0; i < n; i++) {\n    scrambles[i] = generate_random_state_scramble();\n  }\n  return scrambles;\n}\n\n/*\nActual solver logic goes here.\n\nUnlike most of the earlier random-state scramblers I've written before, this one comes with a slight\ncomplication: the FTO's states are _not_ a group. In other words, we can't skip inverting the\nsolution to get the scramble. Not a big deal.\n\nWe assume the D-BR-B-BL corner is solved. (If not, rotate puzzle accordingly.)\n\nPhase 1: Solve a small pyramid around the D-BR-B-BL corner.\n- centres #6, #9 in orbit A and #6, #9 in orbit B\n- edges #8, #9, #10, #11\nReduction: (132/9)**2 * (12*11*10*9) = 2555520\n\nPhase 2: Reduce to LU 2-gen.\n- remaining BR, D centres, one each of F, R centres (#5, #7, #8 in each orbit)\n- edges F-R, F-D, R-BR (#5, #6, #7)\n- corner F-BR (#4)\n- corner orientation constraint on the other four corners\nReduction: 120**2 * (8*7*6) * 10 * 4 = 193536000\n\nPhase 3: Finish solve.\n- remaining centres (#0..#4, #10, #11 in each orbit)\n- edges #0..#4\n- corners #0..#3\nReduction: 210**2 * (5!/2) * (4!/2*2) = 63504000\n\n\n*/\n\nfunction generate_mtable_comb_generic(n, k, permutations) {\n  let N = C(n, k);\n  let nmoves = permutations.length;\n  let [itc, cti] = generate_comb_lookup_tables(n, k);\n  let mtable = Array(nmoves)\n    .fill()\n    .map(() => new Uint32Array(N));\n  for (let i = 0; i < N; i++) {\n    let c = itc[i];\n    let arr = Array(n);\n    for (let j = 0; j < n; j++) {\n      arr[j] = (c >> j) & 1;\n    }\n    for (let m = 0; m < nmoves; m++) {\n      let arr2 = compose(arr, permutations[m]);\n      let c2 = arr2.reduce((acc, x, j) => acc | (x << j), 0);\n      mtable[m][i] = cti[c2];\n    }\n  }\n  return mtable;\n}\n\nfunction generate_mtable_comb4_generic(n, k0, k1, k2, k3, permutations) {\n  let N = C4(n, k0, k1, k2, k3);\n  let nmoves = permutations.length;\n  let [itc, cti] = generate_comb4_lookup_tables(n, k0, k1, k2, k3);\n  let mtable = Array(nmoves)\n    .fill()\n    .map(() => new Uint32Array(N));\n  for (let i = 0; i < N; i++) {\n    let c = itc[i];\n    let arr = Array(n);\n    for (let j = 0; j < n; j++) {\n      arr[j] = (c >> (2 * j)) & 3;\n    }\n    for (let m = 0; m < nmoves; m++) {\n      let arr2 = compose(arr, permutations[m]);\n      let c2 = arr2.reduce((acc, x, j) => acc | (x << (2 * j)), 0);\n      mtable[m][i] = cti[c2];\n    }\n  }\n  return mtable;\n}\n\nfunction generate_mtable_single_generic(permutations) {\n  let n = permutations[0].length;\n  let nmoves = permutations.length;\n  let mtable = Array(nmoves)\n    .fill()\n    .map(() => new Uint32Array(n));\n  for (let i = 0; i < n; i++) {\n    for (let m = 0; m < nmoves; m++) {\n      mtable[m][permutations[m][i]] = i;\n      // we're using right-action convention here,\n      // so we use the *inverse* of the permutation\n      // to track how pieces move.\n    }\n  }\n  return mtable;\n}\n\nfunction combine_mtables(mtable0, mtable1) {\n  let n0 = mtable0[0].length;\n  let n1 = mtable1[0].length;\n  let nmoves = mtable0.length;\n  let combined = Array(nmoves)\n    .fill()\n    .map(() => new Uint32Array(n0 * n1));\n  for (let j = 0; j < n1; j++) {\n    for (let i = 0; i < n0; i++) {\n      let index = i + n0 * j;\n      for (let m = 0; m < nmoves; m++) {\n        combined[m][index] = mtable0[m][i] + n0 * mtable1[m][j];\n      }\n    }\n  }\n  return combined;\n}\n\nfunction trim_unreachable(mtable, origin) {\n  // input: mtable\n  // output: [trimmed mtable, map]\n  let nmoves = mtable.length;\n  let n = mtable[0].length;\n  let reachable = new Uint8Array(n);\n  reachable[origin] = 1;\n  let done = false;\n  while (!done) {\n    done = true;\n    for (let i = 0; i < n; i++) {\n      if (!reachable[i]) {\n        continue;\n      }\n      for (let m = 0; m < nmoves; m++) {\n        if (!reachable[mtable[m][i]]) {\n          reachable[mtable[m][i]] = 1;\n          done = false;\n        }\n      }\n    }\n  }\n  let map = new Int32Array(n).fill(-1);\n  for (let i = 0, counter = 0; i < n; i++) {\n    if (!reachable[i]) {\n      continue;\n    }\n    map[i] = counter;\n    counter++;\n  }\n  return [mtable.map((entry) => reduce_permutation(entry, reachable)), map];\n}\n\nfunction reduce_to_quotient(mtable, origins) {\n  let nmoves = mtable.length;\n  let n = mtable[0].length;\n  let quotient_map = new Int32Array(n).fill(-1);\n  origins.forEach((x) => {\n    quotient_map[x] = 0;\n  });\n  let preimages = [origins];\n  for (let image = 0; image < preimages.length; image++) {\n    let equiv_class = preimages[image];\n    for (let m = 0; m < nmoves; m++) {\n      let j = mtable[m][equiv_class[0]];\n      if (quotient_map[j] !== -1) {\n        continue;\n      } // already looked at those nodes\n      let new_equiv_class = equiv_class.map((x) => mtable[m][x]);\n      let new_image = preimages.length;\n      preimages.push(new_equiv_class);\n      for (let x of new_equiv_class) {\n        if (quotient_map[x] !== -1) {\n          throw \"quotienting failed\";\n        }\n        quotient_map[x] = new_image;\n      }\n    }\n  }\n  let n_quot = preimages.length;\n  let mtable_quot = Array(nmoves)\n    .fill()\n    .map(() => new Int32Array(n_quot));\n  for (let m = 0; m < nmoves; m++) {\n    for (let i = 0; i < n_quot; i++) {\n      mtable_quot[m][i] = quotient_map[mtable[m][preimages[i][0]]];\n    }\n  }\n  return [mtable_quot, quotient_map];\n}\n\nfunction generate_mirrored_coordinate_table(mtable, a, b) {\n  let n = mtable[0].length;\n  let nmoves = mtable.length;\n  let mirror_map = new Int32Array(n).fill(-1);\n  mirror_map[a] = b;\n  mirror_map[b] = a;\n  let done = false;\n  while (!done) {\n    done = true;\n    for (let i = 0; i < n; i++) {\n      if (mirror_map[i] === -1) {\n        continue;\n      }\n      let I = mirror_map[i];\n      for (let m = 0; m < nmoves; m++) {\n        let M = m ^ 1;\n        let new_i = mtable[m][i];\n        let new_I = mtable[M][mtable[M][I]];\n        // convert moves according to this table:\n        // U -> L2\n        // L -> U2\n        // F -> R2\n        // R -> F2\n        if (mirror_map[new_i] === -1) {\n          done = false;\n          mirror_map[new_i] = new_I;\n          mirror_map[new_I] = new_i;\n        } else if (mirror_map[new_i] !== new_I) {\n          throw \"mirroring failed - is the initial map correct?\";\n        }\n      }\n    }\n  }\n  return mirror_map;\n}\n\nfunction bfs(mtable, goal_states) {\n  let N = mtable[0].length;\n  let nmoves = mtable.length;\n  let ptable = new Int8Array(N).fill(-1);\n  for (let state of goal_states) {\n    ptable[state] = 0;\n  }\n  let depth = 0;\n  let done = false;\n  while (!done) {\n    done = true;\n    for (let state = 0; state < N; state++) {\n      if (ptable[state] !== depth) {\n        continue;\n      }\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[move_index][state];\n        while (new_state !== state) {\n          if (ptable[new_state] === -1) {\n            done = false;\n            ptable[new_state] = depth + 1;\n          }\n          new_state = mtable[move_index][new_state];\n        }\n      }\n    }\n    depth++;\n  }\n  return ptable;\n}\n\nfunction* ida_solve_gen(indices, mtables, ptables, moves_left, commute) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= moves_left) {\n    //console.log(`searching depth ${bound}`);\n    yield* ida_search_gen(indices, mtables, ptables, bound, -1, commute);\n    bound++;\n  }\n}\n\nfunction* ida_search_gen(indices, mtables, ptables, bound, last, commute) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && commute[m][last]) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][m][indices[c]];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = ida_search_gen(\n        new_indices,\n        mtables,\n        ptables,\n        bound - 1,\n        m,\n        commute,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][m][new_indices[c]];\n      }\n      r++;\n    }\n  }\n}\n\nfunction solve(facelets, readable = false) {\n  let phase1sol = solve_phase1_gen(facelets).next().value;\n  let facelets2 = apply_move_sequence(facelets, phase1sol);\n  let phase2sol = (\n    readable ? solve_phase2_and_phase3_readable : solve_phase2_and_phase3_fast\n  )(facelets2);\n  let solution = simplify_move_sequence(phase1sol.concat(phase2sol), false);\n  if (\n    apply_move_sequence(facelets, solution).join(\"\") !== solved_state.join(\"\")\n  ) {\n    console.log(\"solving failed!\");\n    console.log(facelets);\n    console.log(phase1sol);\n    console.log(facelets2);\n    console.log(phase2sol);\n    console.log(apply_move_sequence(facelets, solution));\n  }\n  return solution;\n}\n\nlet cached_mtables = {};\nlet cached_ptables = {};\n\n/* Phase 1 stuff */\n\nlet phase1_centre_colour_map = [0, 0, 2, 3, 0, 0, 2, 3];\nfunction index_phase1(facelets) {\n  let [itc, cti] = generate_comb4_lookup_tables(12, 6, 0, 3, 3);\n  let ep = Array(12)\n    .fill()\n    .map((_, i) => get_edge_piece(facelets, i));\n  let edge_coord =\n    ep.indexOf(8) +\n    12 * ep.indexOf(9) +\n    12 ** 2 * ep.indexOf(10) +\n    12 ** 3 * ep.indexOf(11);\n  let [a_coord, b_coord] = [centreA_piece_facelets, centreB_piece_facelets].map(\n    (facelet_indices) => {\n      let arr = facelet_indices.map(\n        (x) => phase1_centre_colour_map[facelets[x]],\n      );\n      return cti[arr.reduce((acc, x, j) => acc | (x << (2 * j)), 0)];\n    },\n  );\n  return [edge_coord, a_coord, b_coord];\n}\n\nfunction generate_phase1_edge_mtable() {\n  if (cached_mtables.phase1_edge) {\n    return cached_mtables.phase1_edge;\n  }\n  let m1 = generate_mtable_single_generic(move_permutations.map((x) => x.ep));\n  let m2 = combine_mtables(m1, m1);\n  let m4 = combine_mtables(m2, m2);\n  return (cached_mtables.phase1_edge = m4);\n}\n\nfunction generate_phase1_edge_ptable() {\n  if (cached_ptables.phase1_edge) {\n    return cached_ptables.phase1_edge;\n  }\n  return (cached_ptables.phase1_edge = bfs(generate_phase1_edge_mtable(), [\n    8 + 12 * 9 + 12 ** 2 * 10 + 12 ** 3 * 11,\n  ]));\n}\n\nfunction generate_phase1_centreA_mtable() {\n  if (cached_mtables.phase1_centreA) {\n    return cached_mtables.phase1_centreA;\n  }\n  return (cached_mtables.phase1_centreA = generate_mtable_comb4_generic(\n    12,\n    6,\n    0,\n    3,\n    3,\n    move_permutations.map((x) => x.ap),\n  ));\n}\n\nfunction generate_phase1_centreB_mtable() {\n  if (cached_mtables.phase1_centreB) {\n    return cached_mtables.phase1_centreB;\n  }\n  return (cached_mtables.phase1_centreB = generate_mtable_comb4_generic(\n    12,\n    6,\n    0,\n    3,\n    3,\n    move_permutations.map((x) => x.bp),\n  ));\n}\n\nfunction generate_phase1_centre_ptable() {\n  // the pruning tables for the two centre orbits are identical due to the specific facelet\n  // labelling we're using.\n  if (cached_ptables.phase1_centre) {\n    return cached_ptables.phase1_centre;\n  }\n  let [itc, cti] = generate_comb4_lookup_tables(12, 6, 0, 3, 3);\n  let goal_states = itc\n    .filter((x) => {\n      let x6 = (x >> 12) & 3;\n      let x9 = (x >> 18) & 3;\n      return x6 === 2 && x9 === 3;\n    })\n    .map((x) => cti[x]);\n  return (cached_ptables.phase1_centre = bfs(\n    generate_phase1_centreB_mtable(),\n    goal_states,\n  ));\n}\n\nfunction* solve_phase1_gen(facelets) {\n  let mtables = [\n    generate_phase1_edge_mtable(),\n    generate_phase1_centreA_mtable(),\n    generate_phase1_centreB_mtable(),\n  ];\n  let ptables = [\n    generate_phase1_edge_ptable(),\n    generate_phase1_centre_ptable(),\n    generate_phase1_centre_ptable(),\n  ];\n  yield* phase1_ida_solve_gen(index_phase1(facelets), mtables, ptables, 15);\n}\n\nfunction* phase1_ida_solve_gen(indices, mtables, ptables, moves_left) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= moves_left) {\n    //console.log(`searching depth ${bound}`);\n    yield* phase1_ida_search_gen(indices, mtables, ptables, bound, -1);\n    bound++;\n  }\n}\n\nfunction* phase1_ida_search_gen(indices, mtables, ptables, bound, last) {\n  let ncoords = 3; //indices.length;\n  let nmoves = 8; //mtables[0].length;\n  let heuristic = Math.max(\n    ptables[0][indices[0]],\n    ptables[1][indices[1]],\n    ptables[2][indices[2]],\n  ); //0;\n  //for (let i = 0; i < ncoords; i++) heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m === last - 4) continue;\n    let new_indices = [];\n    new_indices[0] = mtables[0][m][indices[0]];\n    new_indices[1] = mtables[1][m][indices[1]];\n    new_indices[2] = mtables[2][m][indices[2]];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = phase1_ida_search_gen(\n        new_indices,\n        mtables,\n        ptables,\n        bound - 1,\n        m,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n      new_indices[0] = mtables[0][m][new_indices[0]];\n      new_indices[1] = mtables[1][m][new_indices[1]];\n      new_indices[2] = mtables[2][m][new_indices[2]];\n      r++;\n    }\n  }\n}\n\n/* Phase 2 stuff */\n\nlet phase2_centre_colour_map = [0, 1, 2, 0, 0, 1, 2, 0];\n// we don't care about swapping U and BL centres in phase 2\n\nlet phase2_centre_indices = [0, 1, 2, 3, 4, 5, 7, 8, 10, 11]; // 6 and 9 are already solved in phase 1\nlet phase2_keep = [\n  true,\n  true,\n  true,\n  true,\n  true,\n  true,\n  false,\n  true,\n  true,\n  false,\n  true,\n  true,\n];\nlet phase2_corner_keep = [\n  true,\n  true,\n  true,\n  true,\n  true,\n  false,\n  true,\n  true,\n  true,\n  true,\n  true,\n  false,\n];\n\nfunction index_phase2(facelets) {\n  let [itc, cti] = generate_comb4_lookup_tables(10, 5, 3, 2, 0);\n  let ep = Array(8)\n    .fill()\n    .map((_, i) => get_edge_piece(facelets, i));\n  let edge_coord = ep.indexOf(5) + 8 * ep.indexOf(6) + 8 ** 2 * ep.indexOf(7);\n  let corners = Array(5)\n    .fill()\n    .map((_, i) => get_corner_piece(facelets, i));\n  let cp_inverse_full = invert_permutation(\n    corners\n      .map(([p, o]) => p + 5 * o)\n      .concat(corners.map(([p, o]) => p + 5 * (o ^ 1))),\n  );\n  let cp_inverse = cp_inverse_full.slice(0, 5).map((x) => x % 5);\n  let co_inverse = cp_inverse_full.slice(0, 5).map((x) => (x / 5) | 0);\n  let corner_coord =\n    evenpermutation_to_index(cp_inverse) * 8 +\n    (co_inverse[0] ^ co_inverse[2]) +\n    2 * (co_inverse[0] ^ co_inverse[3]) +\n    4 * co_inverse[4];\n  let [a_coord, b_coord] = [centreA_piece_facelets, centreB_piece_facelets].map(\n    (facelet_indices) => {\n      let arr = compose(facelet_indices, phase2_centre_indices).map(\n        (x) => phase2_centre_colour_map[facelets[x]],\n      );\n      return cti[arr.reduce((acc, x, j) => acc | (x << (2 * j)), 0)];\n    },\n  );\n  // we don't need these move tables, but we do need the reduction maps\n  // that are computed with these (and stored in global vars, yikes)\n  generate_phase2_edge_mtable();\n  generate_phase2_corner_mtable_compact();\n  return [\n    a_coord,\n    b_coord,\n    phase2_corner_reduction_map[corner_coord] +\n      40 * phase2_edge_reduction_map[edge_coord],\n  ];\n}\n\nfunction* solve_phase2_gen(facelets) {\n  yield* phase2_ida_solve_gen(index_phase2(facelets), 30);\n}\n\nfunction solve_phase2(facelets) {\n  return solve_phase2_gen(facelets).next().value;\n}\n\nfunction generate_phase2_centre_mtables() {\n  if (cached_mtables.phase2_centre) {\n    return cached_mtables.phase2_centre;\n  }\n  let a = generate_mtable_comb4_generic(\n    10,\n    5,\n    3,\n    2,\n    0,\n    move_permutations\n      .slice(0, 4)\n      .map((x) => reduce_permutation(x.ap, phase2_keep)),\n  );\n  let b = generate_mtable_comb4_generic(\n    10,\n    5,\n    3,\n    2,\n    0,\n    move_permutations\n      .slice(0, 4)\n      .map((x) => reduce_permutation(x.bp, phase2_keep)),\n  );\n  return (cached_mtables.phase2_centre = [a, b]);\n}\n\nlet phase2_edge_reduction_map;\nfunction generate_phase2_edge_mtable() {\n  if (cached_mtables.phase2_edge) {\n    return cached_mtables.phase2_edge;\n  }\n  let e = generate_mtable_single_generic(\n    move_permutations.slice(0, 4).map((x) => x.ep.slice(0, 8)),\n  );\n  let eee = combine_mtables(e, combine_mtables(e, e));\n  let eee_trimmed;\n  [eee_trimmed, phase2_edge_reduction_map] = trim_unreachable(eee, 0o765);\n  return (cached_mtables.phase2_edge = eee_trimmed);\n}\n\nfunction generate_phase2_corner_mtable() {\n  if (cached_mtables.phase2_corner) {\n    return cached_mtables.phase2_corner;\n  }\n  const HALFFACT5 = factorial(5) / 2; // = 60\n  const N = HALFFACT5 * 8; // = 480\n  const keep = [\n    true,\n    true,\n    true,\n    true,\n    true,\n    false,\n    true,\n    true,\n    true,\n    true,\n    true,\n    false,\n  ];\n  // ignore the sixth and twelfth entries, which encode corner #5's state\n  let mtable = Array(4)\n    .fill()\n    .map(() => new Uint32Array(N));\n  let permutations = move_permutations\n    .slice(0, 4)\n    .map((x) => invert_permutation(reduce_permutation(x.cp, keep)));\n  // using the left-action convention here, so take inverses\n  for (let i = 0; i < N; i++) {\n    let p = index_to_evenpermutation(i >> 3, 5);\n    let o = [0, 0, i & 1, (i >> 1) & 1, (i >> 2) & 1];\n    o[1] = o[2] ^ o[3] ^ o[4];\n    let cp = Array(10);\n    for (let j = 0; j < 5; j++) {\n      cp[j] = p[j] + 5 * o[j];\n      cp[j + 5] = p[j] + 5 * (o[j] ^ 1);\n    }\n    for (let m = 0; m < 4; m++) {\n      let cp2 = compose(permutations[m], cp);\n      let p2 = cp2.slice(0, 5).map((x) => x % 5);\n      let o2 = cp2.slice(0, 5).map((x) => (x / 5) | 0);\n      let orientation_index = (o2[0] ^ o2[2]) + 2 * (o2[0] ^ o2[3]) + 4 * o2[4];\n      mtable[m][i] = evenpermutation_to_index(p2) * 8 + orientation_index;\n    }\n  }\n  return (cached_mtables.phase2_corner = mtable);\n  /*\n\tfar as I can tell, there's no clean way to index the cosets of the corner subgroup in this\n\tphase. so we just do it the dirty way (see `reduce_to_quotient`).\n\t*/\n}\n\nlet phase2_corner_reduction_map;\nfunction generate_phase2_corner_mtable_compact() {\n  if (cached_mtables.phase2_corner_compact) {\n    return cached_mtables.phase2_corner_compact;\n  }\n  [cached_mtables.phase2_corner_compact, phase2_corner_reduction_map] =\n    reduce_to_quotient(\n      generate_phase2_corner_mtable(),\n      phase2_corner_goal_states(),\n    );\n  return cached_mtables.phase2_corner_compact;\n}\n\nfunction generate_phase2_ce_mtable() {\n  if (cached_mtables.phase2_ce) {\n    return cached_mtables.phase2_ce;\n  }\n  let c = generate_phase2_corner_mtable_compact();\n  let e = generate_phase2_edge_mtable();\n  return (cached_mtables.phase2_ce = combine_mtables(c, e));\n}\n\nlet phase2_ce_mirror_map;\nfunction generate_phase2_ce_mirror_map() {\n  if (phase2_ce_mirror_map) {\n    return phase2_ce_mirror_map;\n  }\n  const ce_solved = index_phase2(solved_state)[2];\n  return (phase2_ce_mirror_map = generate_mirrored_coordinate_table(\n    generate_phase2_ce_mtable(),\n    ce_solved,\n    ce_solved,\n  ));\n}\n\nfunction phase2_centre_goal_states() {\n  let [itc, cti] = generate_comb4_lookup_tables(10, 5, 3, 2, 0);\n  return itc.filter((x) => ((x >> 10) & 63) === 41).map((x) => cti[x]);\n  /*\n\tthe combination tracks the centre pieces at indices\n\t0, 1, 2, 3, 4, 5, 7, 8, 10, 11\n\tin little endian order.\n\tright-shifting 10 bits changes this to\n\t5, 7, 8, 10, 11\n\tand masking by 63 keeps only the three least significant digits\n\t5, 7, 8\n\twhich are exactly the pieces we're solving in this phase.\n\t1 + 4 * 2 + 4**2 * 2 = 41\n\tWARNING: this needs to be adjusted if the centre indexing is changed\n\t(also, this returns a Uint32Array, but nothing we do here can possibly cause overflow so\n\tthat's not a problem)\n\t*/\n}\n\nfunction phase2_corner_goal_states() {\n  let mtable = generate_phase2_corner_mtable();\n  let N = mtable[0].length;\n  let flags = Array(N).fill(false);\n  flags[0] = true; /* index 0 is the solved state */\n  let done = false;\n  while (!done) {\n    done = true;\n    for (let i = 0; i < N; i++) {\n      if (flags[i]) {\n        if (!flags[mtable[0][i]]) {\n          done = false;\n          flags[mtable[0][i]] = true;\n        }\n        if (!flags[mtable[1][i]]) {\n          done = false;\n          flags[mtable[1][i]] = true;\n        }\n      }\n    }\n  }\n  return flags.map((_, i) => i).filter((i) => flags[i]);\n}\n\nfunction generate_phase2_ace_ptable() {\n  if (cached_ptables.phase2_ace) {\n    return cached_ptables.phase2_ace;\n  }\n  const [mtable_a, mtable_b] = generate_phase2_centre_mtables();\n  const mtable_ce = generate_phase2_ce_mtable();\n  const Na = 2520;\n  const Nce = 40 * 336;\n  const N = Na * Nce; // = 33868800\n  const ce_solved = index_phase2(solved_state)[2];\n  const max_depth = 9;\n  let ptable = new Int8Array(N).fill(max_depth);\n  for (let a_solved of phase2_centre_goal_states()) {\n    ptable[a_solved + Na * ce_solved] = 0;\n  }\n  for (let depth = 0; depth < max_depth - 1; depth++) {\n    for (\n      let state = ptable.indexOf(depth);\n      state !== -1;\n      state = ptable.indexOf(depth, state + 1)\n    ) {\n      let a = state % Na,\n        ce = (state / Na) | 0;\n      for (let move_index = 0; move_index < 4; move_index++) {\n        let new_a = mtable_a[move_index][a];\n        let new_ce = mtable_ce[move_index][ce];\n        let new_state = new_a + Na * new_ce;\n        if (ptable[new_state] === max_depth) {\n          ptable[new_state] = depth + 1;\n        }\n        new_a = mtable_a[move_index][new_a];\n        new_ce = mtable_ce[move_index][new_ce];\n        new_state = new_a + Na * new_ce;\n        if (ptable[new_state] === max_depth) {\n          ptable[new_state] = depth + 1;\n        }\n      }\n    }\n  }\n  // don't bother filling in the table for depth >=10; this saves a substantial amount of time\n  // on startup at a slight cost of pruning effectiveness\n  return (cached_ptables.phase2_ace = ptable);\n}\n\nfunction* phase2_ida_solve_gen(indices, moves_left) {\n  let [mtable_a, mtable_b] = generate_phase2_centre_mtables();\n  let mtable_ce = generate_phase2_ce_mtable();\n  let ptable_ace = generate_phase2_ace_ptable();\n  let mirror_map = generate_phase2_ce_mirror_map();\n  let [a, b, ce] = indices;\n  let ce_mirror = mirror_map[ce];\n  let bound = Math.max(\n    ptable_ace[a + 2520 * ce],\n    ptable_ace[b + 2520 * ce_mirror],\n  );\n  while (bound <= moves_left) {\n    //console.log(`searching depth ${bound}`);\n    yield* phase2_ida_search_gen(\n      a,\n      b,\n      ce,\n      mtable_a,\n      mtable_b,\n      mtable_ce,\n      ptable_ace,\n      mirror_map,\n      bound,\n      -1,\n    );\n    bound++;\n  }\n}\n\nfunction* phase2_ida_search_gen(\n  a,\n  b,\n  ce,\n  mtable_a,\n  mtable_b,\n  mtable_ce,\n  ptable_ace,\n  mirror_map,\n  bound,\n  last,\n) {\n  let h = Math.max(\n    ptable_ace[a + 2520 * ce],\n    ptable_ace[b + 2520 * mirror_map[ce]],\n  );\n  if (h > bound) {\n    return;\n  }\n  if (bound === 0) {\n    yield [];\n    return;\n  } else if (h === 0) {\n    return;\n  }\n  for (let m = 0; m < 4; m++) {\n    if (m === last) continue;\n    let new_a = a,\n      new_b = b,\n      new_ce = ce;\n    for (let r = 1; r <= 2; r++) {\n      new_a = mtable_a[m][new_a];\n      new_b = mtable_b[m][new_b];\n      new_ce = mtable_ce[m][new_ce];\n      let subpath_gen = phase2_ida_search_gen(\n        new_a,\n        new_b,\n        new_ce,\n        mtable_a,\n        mtable_b,\n        mtable_ce,\n        ptable_ace,\n        mirror_map,\n        bound - 1,\n        m,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n    }\n  }\n}\n\n/* Phase 3 mostly-2-gen stuff */\n\nlet phase3_2gen_centre_indices = [0, 1, 2, 3, 4, 10, 11];\n\nlet phase3_2gen_keep = [\n  true,\n  true,\n  true,\n  true,\n  true,\n  false,\n  false,\n  false,\n  false,\n  false,\n  true,\n  true,\n];\n\nlet phase3_2gen_move_seqs = [\n  [[0, 1]], // U\n  [[1, 1]], // L\n\n  // F U R U' R' F'\n  [\n    [2, 1],\n    [0, 1],\n    [3, 1],\n    [0, 2],\n    [3, 2],\n    [2, 2],\n  ],\n  [\n    [3, 2],\n    [1, 2],\n    [2, 2],\n    [1, 1],\n    [2, 1],\n    [3, 1],\n  ],\n  [\n    [6, 1],\n    [0, 1],\n    [3, 1],\n    [0, 2],\n    [3, 2],\n    [6, 2],\n  ],\n  [\n    [7, 2],\n    [1, 2],\n    [2, 2],\n    [1, 1],\n    [2, 1],\n    [7, 1],\n  ],\n\n  // F U F' U F U F'\n  [\n    [2, 1],\n    [0, 1],\n    [2, 2],\n    [0, 1],\n    [2, 1],\n    [0, 1],\n    [2, 2],\n  ],\n  [\n    [3, 2],\n    [1, 1],\n    [3, 1],\n    [1, 1],\n    [3, 2],\n    [1, 1],\n    [3, 1],\n  ],\n\n  // F R F' L' U' F R F'\n  [\n    [2, 1],\n    [3, 1],\n    [2, 2],\n    [1, 2],\n    [0, 2],\n    [2, 1],\n    [3, 1],\n    [2, 2],\n  ],\n  [\n    [3, 2],\n    [2, 2],\n    [3, 1],\n    [0, 1],\n    [1, 1],\n    [3, 2],\n    [2, 2],\n    [3, 1],\n  ],\n  [\n    [6, 1],\n    [0, 1],\n    [6, 2],\n    [0, 2],\n    [1, 2],\n    [6, 1],\n    [0, 1],\n    [6, 2],\n  ],\n  [\n    [7, 2],\n    [1, 2],\n    [7, 1],\n    [1, 1],\n    [0, 1],\n    [7, 2],\n    [1, 2],\n    [7, 1],\n  ],\n\n  // F R' F' R U F' L F\n  [\n    [2, 1],\n    [3, 2],\n    [2, 2],\n    [3, 1],\n    [0, 1],\n    [2, 2],\n    [1, 1],\n    [2, 1],\n  ],\n  [\n    [3, 2],\n    [2, 1],\n    [3, 1],\n    [2, 2],\n    [1, 2],\n    [3, 1],\n    [0, 2],\n    [3, 2],\n  ],\n  [\n    [6, 1],\n    [0, 2],\n    [6, 2],\n    [7, 1],\n    [6, 1],\n    [1, 2],\n    [7, 1],\n    [6, 1],\n  ],\n  [\n    [7, 2],\n    [1, 1],\n    [7, 1],\n    [6, 2],\n    [7, 2],\n    [0, 1],\n    [6, 2],\n    [7, 2],\n  ],\n\n  // F' L' F' R' F' R' U' R'\n  [\n    [2, 2],\n    [1, 2],\n    [2, 2],\n    [3, 2],\n    [2, 2],\n    [3, 2],\n    [0, 2],\n    [3, 2],\n  ],\n  [\n    [6, 2],\n    [7, 2],\n    [1, 2],\n    [0, 2],\n    [1, 2],\n    [0, 2],\n    [6, 2],\n    [7, 2],\n  ],\n  /*\n[[2,1], [0,2], [2,2], [0,2], [2,1], [3,1], [0,2], [3,2], [2,2]], // F U' F' U' F R U' R' F'\n[[3,2], [1,1], [3,1], [1,1], [3,2], [2,2], [1,1], [2,1], [3,1]], // R' L R L R' F' L F R\n[[6,1], [3,2], [6,2], [1,2], [6,1], [0,1], [3,2], [0,2], [6,2]], // f R' f' L' f U R' U' f'\n[[7,2], [2,1], [7,1], [0,1], [7,2], [1,2], [2,1], [1,1], [7,1]], // r' F r U r' L' F L r\n[[2,1], [0,1], [3,1], [0,2], [3,2], [0,1], [3,1], [0,2], [3,2], [2,2]], // F (U R U' R')2 F'\n[[3,2], [1,2], [2,2], [1,1], [2,1], [1,2], [2,2], [1,1], [2,1], [3,1]], // R' (L' F' L F)2 R\n[[6,1], [0,1], [3,1], [0,2], [3,2], [0,1], [3,1], [0,2], [3,2], [6,2]], // f (U R U' R')2 f'\n[[7,2], [1,2], [2,2], [1,1], [2,1], [1,2], [2,2], [1,1], [2,1], [7,1]], // r' (L' F' L F)2 r\n*/\n];\nphase3_2gen_move_seqs = phase3_2gen_move_seqs.concat(\n  phase3_2gen_move_seqs.map((seq) => invert_move_sequence(seq)),\n);\nlet phase3_2gen_nmoves = phase3_2gen_move_seqs.length; // = 36\n/*\nThe moves we're using for this phase:\nU\nL\nF U R U' R' F'\nR' L' F' L F R\nf U R U' R' f'\nr' L' F' L F r\nF U F' U F U F' (= F' U F U F' U F = r' F r U r' F r = r l U' l F l r')\nR' L R L R' L R (= R L R' L R L R' = f R f' L f R f' = f' u R u L' u f)\n\nF R F' L' U' F R F'\nR' F' R U L R' F' R\nf U f' U' L' f U f'\nr' L' r L U r' L' r\n\nF R' F' R U F' L F\nR' F R F' L' R U' R'\nf U' f' r f L' r f\nr' L r f' r' U f' r'\n\nF' L' F' R' F' R' U' R'\nf' r' L' U' L' U' f' r'\n\nand the inverses of the above\n\nThese are the atomic 4-gen move sequences of length <= 8 where the induced permutations lie in the\n<U,L> group (verified with GAP, barring transcription errors).\n\nTemporarily going out of LU 2-gen can sometimes save _many_ moves, e.g. the F R U R' U' F' scramble\nobviously has a 6-move 4-gen solution (F U R U' R' F'), but the optimal 2-gen solution is 24 moves:\nU L' U L' U' L' U' L U' L U L' U L' U L U L' U' L U' L U L'.\n*/\n\nlet phase3_2gen_facelet_permutations = phase3_2gen_move_seqs.map((seq) =>\n  apply_move_sequence(permutation_from_cycles([], 72), seq),\n);\nlet phase3_2gen_piece_permutations = phase3_2gen_facelet_permutations.map(\n  convert_move_to_permutations,\n);\nlet phase3_2gen_move_orders =\n  phase3_2gen_facelet_permutations.map(permutation_order);\n\nfunction index_phase3_2gen(facelets) {\n  let [itc, cti] = generate_comb4_lookup_tables(7, 3, 2, 0, 2);\n  let ep = Array(5)\n    .fill()\n    .map((_, i) => get_edge_piece(facelets, i));\n  let edge_coord = evenpermutation_to_index(ep);\n  let corners = Array(4)\n    .fill()\n    .map((_, i) => get_corner_piece(facelets, i));\n  let corner_coord =\n    evenpermutation_to_index(corners.map((x) => x[0])) * 2 +\n    corners.find((x) => x[0] === 0)[1];\n  let [a_coord, b_coord] = [centreA_piece_facelets, centreB_piece_facelets].map(\n    (facelet_indices) => {\n      let arr = compose(facelet_indices, phase3_2gen_centre_indices).map(\n        (x) => facelets[x] % 4,\n      );\n      return cti[arr.reduce((acc, x, j) => acc | (x << (2 * j)), 0)];\n    },\n  );\n  return [a_coord + 210 * b_coord, corner_coord + 24 * edge_coord];\n}\n\nfunction generate_phase3_2gen_edge_mtable() {\n  if (cached_mtables.phase3_2gen_edge) {\n    return cached_mtables.phase3_2gen_edge;\n  }\n  const HALFFACT5 = factorial(5) / 2; // = 60\n  let mtable = Array(phase3_2gen_nmoves)\n    .fill()\n    .map(() => new Uint32Array(HALFFACT5));\n  let permutations = phase3_2gen_piece_permutations.map((x) =>\n    x.ep.slice(0, 5),\n  );\n  for (let i = 0; i < HALFFACT5; i++) {\n    let p = index_to_evenpermutation(i, 5);\n    for (let m = 0; m < phase3_2gen_nmoves; m++) {\n      mtable[m][i] = evenpermutation_to_index(compose(p, permutations[m]));\n    }\n  }\n  return (cached_mtables.phase3_2gen_edge = mtable);\n}\n\n// the group of corner states is the binary tetrahedral group 2T, where |2T| = 24\nfunction generate_phase3_2gen_corner_mtable() {\n  if (cached_mtables.phase3_2gen_corner) {\n    return cached_mtables.phase3_2gen_corner;\n  }\n  const HALFFACT4 = factorial(4) / 2; // = 12\n  const N = HALFFACT4 * 2; // = 24\n  const keep = [\n    true,\n    true,\n    true,\n    true,\n    false,\n    false,\n    true,\n    true,\n    true,\n    true,\n    false,\n    false,\n  ];\n  let mtable = Array(phase3_2gen_nmoves)\n    .fill()\n    .map(() => new Uint32Array(N));\n  let permutations = phase3_2gen_piece_permutations.map((x) =>\n    reduce_permutation(x.cp, keep).slice(0, 4),\n  );\n  for (let i = 0; i < N; i += 2) {\n    let p = index_to_evenpermutation(i >> 1, 4);\n    let cp = p.concat(p.map((x) => x + 4));\n    for (let m = 0; m < phase3_2gen_nmoves; m++) {\n      let cp2 = compose(cp, permutations[m]);\n      let p2 = cp2.map((x) => x % 4);\n      let o2 = cp2.find((x) => x % 4 === 0) >> 2;\n      mtable[m][i] = evenpermutation_to_index(p2) * 2 + o2;\n      mtable[m][i + 1] = evenpermutation_to_index(p2) * 2 + (o2 ^ 1);\n    }\n  }\n  return (cached_mtables.phase3_2gen_corner = mtable);\n}\n\nfunction generate_phase3_2gen_corneredge_mtable() {\n  if (cached_mtables.phase3_2gen_corneredge) {\n    return cached_mtables.phase3_2gen_corneredge;\n  }\n  return (cached_mtables.phase3_2gen_corneredge = combine_mtables(\n    generate_phase3_2gen_corner_mtable(),\n    generate_phase3_2gen_edge_mtable(),\n  ));\n}\n\nfunction generate_phase3_2gen_centre_mtable() {\n  if (cached_mtables.phase3_2gen_centre) {\n    return cached_mtables.phase3_2gen_centre;\n  }\n  let mtable_a = generate_mtable_comb4_generic(\n    7,\n    3,\n    2,\n    0,\n    2,\n    phase3_2gen_piece_permutations.map((x) =>\n      reduce_permutation(x.ap, phase3_2gen_keep),\n    ),\n  );\n  let mtable_b = generate_mtable_comb4_generic(\n    7,\n    3,\n    2,\n    0,\n    2,\n    phase3_2gen_piece_permutations.map((x) =>\n      reduce_permutation(x.bp, phase3_2gen_keep),\n    ),\n  );\n  cached_mtables.phase3_2gen_centreA = mtable_a;\n  cached_mtables.phase3_2gen_centreB = mtable_b;\n  return (cached_mtables.phase3_2gen_centre = combine_mtables(\n    mtable_a,\n    mtable_b,\n  ));\n}\n\nlet phase3_2gen_depth_table;\nfunction generate_phase3_2gen_depth_table() {\n  if (phase3_2gen_depth_table) {\n    return phase3_2gen_depth_table;\n  }\n  const mtable_ab = generate_phase3_2gen_centre_mtable();\n  const mtable_ce = generate_phase3_2gen_corneredge_mtable();\n  const Nab = mtable_ab[0].length; // = 44100\n  const Nce = mtable_ce[0].length; // = 1440\n  const N = Nab * Nce; // = 63504000\n  const max_depth = 25; // pre-determined; hard-coding this makes the algorithm a bit faster\n  const all_weights = phase3_2gen_move_seqs.map((seq) => seq.length);\n  const table = new Int8Array(N).fill(max_depth);\n  const solved_indices = index_phase3_2gen(solved_state);\n  table[solved_indices[0] + Nab * solved_indices[1]] = 0;\n  let depth = 0;\n  let done = false;\n  while (!done && depth < max_depth - 1) {\n    done = true;\n    //console.log(`scanning depth ${depth}`);\n    let move_indices = Array(phase3_2gen_nmoves)\n      .fill()\n      .map((x, i) => i)\n      .filter((m) => all_weights[m] + depth < max_depth);\n    move_indices.sort((m, mm) => all_weights[m] - all_weights[mm]);\n    let weights = compose(all_weights, move_indices);\n    let mtable_ab_pruned = compose(mtable_ab, move_indices);\n    let mtable_ce_pruned = compose(mtable_ce, move_indices);\n    let nmoves = move_indices.length;\n    //console.log(move_indices);\n    for (\n      let state = table.indexOf(depth);\n      state !== -1;\n      state = table.indexOf(depth, state + 1)\n    ) {\n      let ab = state % Nab,\n        ce = (state / Nab) | 0;\n      for (let mi = 0; mi < nmoves; mi++) {\n        let weight = weights[mi];\n        let new_ab = mtable_ab_pruned[mi][ab];\n        let new_ce = mtable_ce_pruned[mi][ce];\n        let new_state = new_ab + Nab * new_ce;\n        if (table[new_state] > depth + weight) {\n          done = false;\n          table[new_state] = depth + weight;\n        }\n      }\n    }\n    depth++;\n  }\n  return (phase3_2gen_depth_table = table);\n}\n\nlet phase3_2gen_ace_table;\nfunction generate_phase3_2gen_ace_table() {\n  if (phase3_2gen_ace_table) {\n    return phase3_2gen_ace_table;\n  }\n  const mtable_ab = generate_phase3_2gen_centre_mtable();\n  const mtable_a = cached_mtables.phase3_2gen_centreA;\n  const mtable_ce = generate_phase3_2gen_corneredge_mtable();\n  const Na = mtable_a[0].length; // = 210\n  const Nce = mtable_ce[0].length; // = 1440\n  const N = Na * Nce; // = 302400\n  const max_depth = 25; // pre-determined; hard-coding this makes the algorithm a bit faster\n  const all_weights = phase3_2gen_move_seqs.map((seq) => seq.length);\n  const table = new Int8Array(N).fill(max_depth);\n  const solved_indices = index_phase3_2gen(solved_state);\n  table[(solved_indices[0] % Na) + Na * solved_indices[1]] = 0;\n  let depth = 0;\n  let done = false;\n  while (!done && depth < max_depth - 1) {\n    done = true;\n    //console.log(`scanning depth ${depth}`);\n    let move_indices = Array(phase3_2gen_nmoves)\n      .fill()\n      .map((x, i) => i)\n      .filter((m) => all_weights[m] + depth < max_depth);\n    move_indices.sort((m, mm) => all_weights[m] - all_weights[mm]);\n    let weights = compose(all_weights, move_indices);\n    let mtable_a_pruned = compose(mtable_a, move_indices);\n    let mtable_ce_pruned = compose(mtable_ce, move_indices);\n    let nmoves = move_indices.length;\n    //console.log(move_indices);\n    for (\n      let state = table.indexOf(depth);\n      state !== -1;\n      state = table.indexOf(depth, state + 1)\n    ) {\n      let a = state % Na,\n        ce = (state / Na) | 0;\n      for (let mi = 0; mi < nmoves; mi++) {\n        let weight = weights[mi];\n        let new_a = mtable_a_pruned[mi][a];\n        let new_ce = mtable_ce_pruned[mi][ce];\n        let new_state = new_a + Na * new_ce;\n        if (table[new_state] > depth + weight) {\n          done = false;\n          table[new_state] = depth + weight;\n        }\n      }\n    }\n    depth++;\n  }\n  return (phase3_2gen_ace_table = table);\n}\n\nlet phase3_2gen_ce_mirror_map;\nfunction generate_phase3_2gen_ce_mirror_map() {\n  if (phase3_2gen_ce_mirror_map) {\n    return phase3_2gen_ce_mirror_map;\n  }\n  const mtable_ce = generate_phase3_2gen_corneredge_mtable().slice(0, 2);\n  const solved_indices = index_phase3_2gen(solved_state);\n  return (phase3_2gen_ce_mirror_map = generate_mirrored_coordinate_table(\n    mtable_ce,\n    solved_indices[1],\n    solved_indices[1],\n  ));\n}\n\n/*\nfunction solve_phase3_2gen(facelets, indices=index_phase3_2gen(facelets), simplify=true)\n{\n\tlet [ab, ce] = indices;\n\tlet Nab = 44100;\n\tlet mtable_ab = generate_phase3_2gen_centre_mtable();\n\tlet mtable_ce = generate_phase3_2gen_corneredge_mtable();\n\tlet depth_table = generate_phase3_2gen_depth_table();\n\tlet seq = [];\n\twhile (depth_table[ab + Nab*ce] > 0)\n\t{\n\t\tlet distance = depth_table[ab + Nab*ce];\n\t\tfor (let m = 0; m < phase3_2gen_nmoves; m++)\n\t\t{\n\t\t\tlet new_ab = mtable_ab[m][ab];\n\t\t\tlet new_ce = mtable_ce[m][ce];\n\t\t\tlet new_distance = depth_table[new_ab + Nab*new_ce];\n\t\t\tif (new_distance === distance-phase3_2gen_move_seqs[m].length)\n\t\t\t{\n\t\t\t\tseq = seq.concat(phase3_2gen_move_seqs[m]);\n\t\t\t\tab = new_ab;\n\t\t\t\tce = new_ce;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn simplify ? simplify_move_sequence(seq) : seq;\n}\n*/\n\nfunction solve_phase3_2gen(facelets, indices = index_phase3_2gen(facelets)) {\n  //const THRESHOLD = 31;\n  let [ab, ce] = indices;\n  let a = ab % 210,\n    b = Math.floor(ab / 210);\n  let mtable_ab = generate_phase3_2gen_centre_mtable();\n  let mtable_a = cached_mtables.phase3_2gen_centreA;\n  let mtable_b = cached_mtables.phase3_2gen_centreB;\n  let mtable_ce = generate_phase3_2gen_corneredge_mtable();\n  let ace_table = generate_phase3_2gen_ace_table();\n  let mirror_map_ce = generate_phase3_2gen_ce_mirror_map();\n  let bound = 0;\n  while (true) {\n    let gen = solve_phase3_2gen_ida(\n      a,\n      b,\n      ce,\n      mtable_a,\n      mtable_b,\n      mtable_ce,\n      ace_table,\n      mirror_map_ce,\n      bound,\n    );\n    for (let solution of gen) {\n      return solution.map((m) => phase3_2gen_move_seqs[m]).flat();\n    }\n    bound++;\n  }\n}\n\nfunction solve_phase3_2gen_readable(\n  facelets,\n  indices = index_phase3_2gen(facelets),\n) {\n  //const THRESHOLD = 31;\n  let [ab, ce] = indices;\n  let a = ab % 210,\n    b = Math.floor(ab / 210);\n  let mtable_ab = generate_phase3_2gen_centre_mtable();\n  let mtable_a = cached_mtables.phase3_2gen_centreA;\n  let mtable_b = cached_mtables.phase3_2gen_centreB;\n  let mtable_ce = generate_phase3_2gen_corneredge_mtable();\n  //let depth_table = generate_phase3_2gen_depth_table();\n  let ace_table = generate_phase3_2gen_ace_table();\n  let mirror_map_ce = generate_phase3_2gen_ce_mirror_map();\n  let initial = solve_phase3_2gen(facelets).length;\n  let best_score = Infinity;\n  let best_solution;\n  //console.log(`initial: ${initial}`);\n  for (let bound = initial; bound <= initial + 0; bound++) {\n    let gen = solve_phase3_2gen_ida(\n      a,\n      b,\n      ce,\n      mtable_a,\n      mtable_b,\n      mtable_ce,\n      ace_table,\n      mirror_map_ce,\n      bound,\n    );\n    for (let solution of gen) {\n      let expanded = solution.map((m) => phase3_2gen_move_seqs[m]).flat();\n      let simplified = simplify_move_sequence(expanded);\n      let score = grade_readability(simplified);\n      if (score < best_score) {\n        best_score = score;\n        best_solution = simplified;\n        //console.log(`${score} ${stringify_move_sequence(simplified, true)}`);\n        //if (score <= THRESHOLD) {break search;}\n      }\n    }\n  }\n  return best_solution;\n}\n\nfunction alternation_penalty(x) {\n  return ((x - 1) * (x - 2)) / 2;\n  // A B A B A       costs 1\n  // A B A B A B     costs 3\n  // A B A B A B A   costs 6\n  // A B A B A B A B costs 10\n  // etc.\n  // this should be chosen to be a convex function\n}\n\nfunction grade_readability(seq) {\n  let nowide = stringify_move_sequence(seq, true).replace(/'/g, \"\").split(\" \");\n  return (\n    seq.length +\n    alternations(nowide)\n      .map(alternation_penalty)\n      .reduce((x, y) => x + y, 0)\n  );\n}\n\nfunction alternations(seq) {\n  // return a list of \"alternating\" run lengths\n  // convention:\n  // A B       does not count\n  // A B A     counts as length 1\n  // A B A B   counts as length 2\n  // A B A B A counts as length 3\n  // etc.\n  if (seq.length < 3) {\n    return [];\n  }\n  let n = seq.length;\n  let a = [];\n  for (let i = 0; i < n - 2; i++) {\n    a[i] = seq[i] === seq[i + 2];\n  }\n  a.push(false);\n  let i = -1;\n  let runs = [];\n  while (i < n - 2) {\n    i = a.indexOf(true, i + 1);\n    if (i === -1) {\n      break;\n    }\n    let j = a.indexOf(false, i + 1);\n    runs.push(j - i);\n    i = j;\n  }\n  return runs;\n}\n\nfunction* solve_phase3_2gen_ida(\n  a,\n  b,\n  ce,\n  mtable_a,\n  mtable_b,\n  mtable_ce,\n  ace_table,\n  mirror_map_ce,\n  bound,\n  last = -1,\n) {\n  let h_ace = ace_table[a + 210 * ce];\n  let h_bce = ace_table[b + 210 * mirror_map_ce[ce]];\n  let h = Math.max(h_ace, h_bce);\n  //console.log(h_ace, h_bce, bound);\n  if (h > bound) {\n    return;\n  }\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (h === 0) {\n    return;\n  } // this solution includes redundant moves\n  for (let m = 0; m < phase3_2gen_nmoves; m++) {\n    if (m === last && phase3_2gen_move_orders[m] <= 3) {\n      continue;\n    }\n    let new_a = mtable_a[m][a];\n    let new_b = mtable_b[m][b];\n    let new_ce = mtable_ce[m][ce];\n    let new_bound = bound - phase3_2gen_move_seqs[m].length;\n    if (new_bound < 0) {\n      continue;\n    }\n    let subpath_gen = solve_phase3_2gen_ida(\n      new_a,\n      new_b,\n      new_ce,\n      mtable_a,\n      mtable_b,\n      mtable_ce,\n      ace_table,\n      mirror_map_ce,\n      new_bound,\n      m,\n    );\n    while (true) {\n      let { value: subpath, done } = subpath_gen.next();\n      if (done) {\n        break;\n      }\n      yield [m].concat(subpath);\n    }\n  }\n}\n\n/* Some glue code */\n\nfunction solve_phase2_and_phase3_fast(\n  facelets,\n  phase2_attempts = 200,\n  cap = 24,\n) {\n  let pool = [];\n  let gen = solve_phase2_gen(facelets);\n  let facelets_t2 = compose(facelets, move_X).map((x) => x ^ 1);\n  let gen_t2 = solve_phase2_gen(facelets_t2);\n  let best = Array(1000);\n  // phase 2 always takes <= 15 moves and phase 3 <= 25 moves, so this is a safe upper bound\n  for (let i = 0; i < phase2_attempts; i++) {\n    {\n      let { value, done } = gen.next();\n      if (!done) {\n        let intermediate_facelets = apply_move_sequence(facelets, value);\n        let solution = value.concat(solve_phase3_2gen(intermediate_facelets));\n        if (solution.length <= cap) {\n          return solution;\n        } else if (solution.length < best.length) {\n          best = solution;\n        }\n      }\n    }\n    {\n      let { value, done } = gen_t2.next();\n      if (!done) {\n        let intermediate_facelets = apply_move_sequence(facelets_t2, value);\n        let solution = value\n          .concat(solve_phase3_2gen(intermediate_facelets))\n          .map(([m, r]) => [m ^ 2, r]);\n        if (solution.length <= cap) {\n          return solution;\n        } else if (solution.length < best.length) {\n          best = solution;\n        }\n      }\n    }\n  }\n  return best;\n}\n\nfunction solve_phase2_and_phase3_readable(\n  facelets,\n  phase2_attempts = 20,\n  cap = 30,\n) {\n  let pool = [];\n  let gen = solve_phase2_gen(facelets);\n  let facelets_t2 = compose(facelets, move_X).map((x) => x ^ 1);\n  let gen_t2 = solve_phase2_gen(facelets_t2);\n  let best;\n  let best_score = Infinity;\n  for (let i = 0; i < phase2_attempts; i++) {\n    {\n      let { value, done } = gen.next();\n      if (!done) {\n        let intermediate_facelets = apply_move_sequence(facelets, value);\n        let solution = simplify_move_sequence(\n          value.concat(solve_phase3_2gen_readable(intermediate_facelets)),\n        );\n        let score = grade_readability(solution);\n        if (score <= cap) {\n          return solution;\n        } else if (score < best_score) {\n          best = solution;\n          best_score = score;\n        }\n      }\n    }\n    {\n      let { value, done } = gen_t2.next();\n      if (!done) {\n        let intermediate_facelets = apply_move_sequence(facelets_t2, value);\n        let solution = simplify_move_sequence(\n          value.concat(solve_phase3_2gen_readable(intermediate_facelets)),\n        );\n        solution = solution.map(([m, r]) => [m ^ 2, r]);\n        let score = grade_readability(solution);\n        if (score <= cap) {\n          return solution;\n        } else if (score < best_score) {\n          best = solution;\n          best_score = score;\n        }\n      }\n    }\n  }\n  return best;\n}\n\nconst randomUintBelow = randomUIntBelowFactory();\nexport async function randomFTOScrambleString() {\n  return generate_random_state_scramble(await randomUintBelow);\n}\n"],"names":["$650b4b438682fb50$var$factorial","n","f","i","$650b4b438682fb50$var$C","k","c","$650b4b438682fb50$var$C4","k0","k1","k2","k3","$650b4b438682fb50$var$index_to_evenpermutation","ind","perm","parity","i1","j","$650b4b438682fb50$var$evenpermutation_to_index","slice","length","e","x","$650b4b438682fb50$var$permutation_to_index","$650b4b438682fb50$var$evenpermutation8_to_index","$650b4b438682fb50$var$index_to_evenpermutation8","index_in_set_bits","Int8Array","look_up_set_bits","i2","counter","unused","v","a","$650b4b438682fb50$var$random_permutation","randomUintBelow2","p","r","$650b4b438682fb50$var$random_even_permutation","A","$650b4b438682fb50$var$permutation_parity","$650b4b438682fb50$var$ctz","Math","clz32","$650b4b438682fb50$var$comb_lookup_tables","$650b4b438682fb50$var$generate_comb_lookup_tables","key","total","index_to_comb_table","Uint32Array","comb_to_index_table","fill","t","$650b4b438682fb50$var$popcount","$650b4b438682fb50$var$spread_bits","$650b4b438682fb50$var$comb4_lookup_tables","$650b4b438682fb50$var$generate_comb4_lookup_tables","join","itcl","ctil","itch","ctih","index_to_comb4_table","comb4_to_index_table","index","ch","cl","y","$650b4b438682fb50$var$compose","B","C2","$650b4b438682fb50$var$compose3","D","$650b4b438682fb50$var$permutation_from_cycles","cycles","cycle","i3","$650b4b438682fb50$var$reduce_permutation","keep","count","Array","nn","reduced","i4","$650b4b438682fb50$var$invert_permutation","inverse","$650b4b438682fb50$var$lcm","b","abs","$650b4b438682fb50$var$gcd","$650b4b438682fb50$var$solved_state","map","_","$650b4b438682fb50$var$move_U","$650b4b438682fb50$var$move_Ui","$650b4b438682fb50$var$move_X","$650b4b438682fb50$var$move_Z","$650b4b438682fb50$var$move_L","$650b4b438682fb50$var$move_F","$650b4b438682fb50$var$move_R","$650b4b438682fb50$var$move_Uw","$650b4b438682fb50$var$move_Lw","$650b4b438682fb50$var$move_Fw","$650b4b438682fb50$var$move_Rw","$650b4b438682fb50$var$colour_map","$650b4b438682fb50$var$corner_piece_facelets","$650b4b438682fb50$var$edge_piece_facelets","$650b4b438682fb50$var$centreA_piece_facelets","$650b4b438682fb50$var$centreB_piece_facelets","$650b4b438682fb50$var$get_corner_piece","facelets","location","colourA","colourB","$650b4b438682fb50$var$identify_corner_piece","$650b4b438682fb50$var$get_edge_piece","$650b4b438682fb50$var$identify_edge_piece","$650b4b438682fb50$var$set_corner_piece","value","orientation","indices","colours","$650b4b438682fb50$var$set_edge_piece","$650b4b438682fb50$var$convert_move_to_permutations","move","state","cp_half","o","concat","indexOf","$650b4b438682fb50$var$moves","$650b4b438682fb50$var$move_names","$650b4b438682fb50$var$move_permutations","$650b4b438682fb50$var$stringify_move_sequence","move_sequence","no_wide","U","L","F","R","BR","BL","ordering","rotations","m","names","split","suffixes","$650b4b438682fb50$var$apply_move_sequence","$650b4b438682fb50$var$invert_move_sequence","reverse","$650b4b438682fb50$var$simplify_move_sequence","make_noise","last_move","simplified","pop","splice","push","console","log","$650b4b438682fb50$var$generate_random_state_scramble","readable","phase1sol","mtables","$650b4b438682fb50$var$generate_phase1_edge_mtable","$650b4b438682fb50$var$generate_phase1_centreA_mtable","$650b4b438682fb50$var$generate_phase1_centreB_mtable","ptables","$650b4b438682fb50$var$generate_phase1_edge_ptable","$650b4b438682fb50$var$generate_phase1_centre_ptable","moves_left","ncoords","bound","max","$650b4b438682fb50$var$phase1_ida_search_gen","$650b4b438682fb50$var$phase1_ida_solve_gen","itc","cti","ep","edge_coord","a_coord","b_coord","facelet_indices","arr","$650b4b438682fb50$var$phase1_centre_colour_map","reduce","acc","$650b4b438682fb50$var$index_phase1","$650b4b438682fb50$var$solve_phase1_gen","next","facelets2","phase2sol","$650b4b438682fb50$var$solve_phase2_and_phase3_readable","$650b4b438682fb50$var$solve_phase2_and_phase3_fast","solution","$650b4b438682fb50$var$solve","cp","co","i5","i6","$650b4b438682fb50$var$random_state","$650b4b438682fb50$var$generate_mtable_comb4_generic","permutations","N","nmoves","mtable","j1","c2","$650b4b438682fb50$var$generate_mtable_single_generic","$650b4b438682fb50$var$combine_mtables","mtable0","mtable1","n0","n1","combined","$650b4b438682fb50$var$generate_mirrored_coordinate_table","mirror_map","Int32Array","done","I","M","new_i","new_I","$650b4b438682fb50$var$bfs","goal_states","ptable","depth","move_index","new_state","$650b4b438682fb50$var$cached_mtables","$650b4b438682fb50$var$cached_ptables","phase1_edge","m1","m2","m4","phase1_centreA","ap","phase1_centreB","bp","phase1_centre","filter","last","heuristic","new_indices","some","subpath_gen","subpath","$650b4b438682fb50$var$phase2_edge_reduction_map","$650b4b438682fb50$var$phase2_corner_reduction_map","$650b4b438682fb50$var$phase2_ce_mirror_map","$650b4b438682fb50$var$phase2_centre_colour_map","$650b4b438682fb50$var$phase2_centre_indices","$650b4b438682fb50$var$phase2_keep","$650b4b438682fb50$var$index_phase2","corners","cp_inverse_full","cp_inverse","co_inverse","corner_coord","$650b4b438682fb50$var$generate_phase2_edge_mtable","$650b4b438682fb50$var$generate_phase2_corner_mtable_compact","$650b4b438682fb50$var$solve_phase2_gen","mtable_a","mtable_b","$650b4b438682fb50$var$generate_phase2_centre_mtables","mtable_ce","$650b4b438682fb50$var$generate_phase2_ce_mtable","ptable_ace","phase2_ace","Na","ce_solved","max_depth","a_solved","$650b4b438682fb50$var$phase2_centre_goal_states","ce","new_a","new_ce","$650b4b438682fb50$var$generate_phase2_ace_ptable","$650b4b438682fb50$var$generate_phase2_ce_mirror_map","ce_mirror","$650b4b438682fb50$var$phase2_ida_search_gen","$650b4b438682fb50$var$phase2_ida_solve_gen","phase2_centre","phase2_edge","eee_trimmed","eee","origin","reachable","Uint8Array","entry","$650b4b438682fb50$var$trim_unreachable","$650b4b438682fb50$var$generate_phase2_corner_mtable","phase2_corner","cp2","p2","o2","orientation_index","phase2_corner_compact","origins","quotient_map","forEach","preimages","image","equiv_class","new_equiv_class","new_image","n_quot","mtable_quot","$650b4b438682fb50$var$reduce_to_quotient","flags","$650b4b438682fb50$var$phase2_corner_goal_states","phase2_ce","h","new_b","$650b4b438682fb50$var$phase3_2gen_ace_table","$650b4b438682fb50$var$phase3_2gen_ce_mirror_map","$650b4b438682fb50$var$phase3_2gen_centre_indices","$650b4b438682fb50$var$phase3_2gen_keep","$650b4b438682fb50$var$phase3_2gen_move_seqs","$650b4b438682fb50$var$phase3_2gen_nmoves","seq","$650b4b438682fb50$var$phase3_2gen_facelet_permutations","$650b4b438682fb50$var$phase3_2gen_piece_permutations","$650b4b438682fb50$var$phase3_2gen_move_orders","order","visited","cycle_length","$650b4b438682fb50$var$index_phase3_2gen","find","$650b4b438682fb50$var$generate_phase3_2gen_corneredge_mtable","phase3_2gen_corneredge","phase3_2gen_corner","$650b4b438682fb50$var$generate_phase3_2gen_corner_mtable","phase3_2gen_edge","HALFFACT5","$650b4b438682fb50$var$generate_phase3_2gen_edge_mtable","$650b4b438682fb50$var$generate_phase3_2gen_centre_mtable","phase3_2gen_centre","phase3_2gen_centreA","phase3_2gen_centreB","$650b4b438682fb50$var$generate_phase3_2gen_ace_table","all_weights","table","solved_indices","move_indices","sort","mm","weights","mtable_a_pruned","mtable_ce_pruned","mi","weight","$650b4b438682fb50$var$generate_phase3_2gen_ce_mirror_map","$650b4b438682fb50$var$solve_phase3_2gen","ab","floor","ace_table","mirror_map_ce","gen","$650b4b438682fb50$var$solve_phase3_2gen_ida","flat","$650b4b438682fb50$var$solve_phase3_2gen_readable","best_solution","initial","best_score","Infinity","score","$650b4b438682fb50$var$grade_readability","$650b4b438682fb50$var$alternation_penalty","nowide","replace","runs","$650b4b438682fb50$var$alternations","h_ace","h_bce","new_bound","phase2_attempts","cap","facelets_t2","gen_t2","best","intermediate_facelets","$650b4b438682fb50$var$randomUintBelow","$80rC8","randomUIntBelowFactory","$650b4b438682fb50$export$77ea2542cbd1e7a9"],"version":3,"file":"fto-solver-HI6NIV74.11696b83.js.map"}