{"mappings":"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","sources":["node_modules/cubing/dist/esm/master_tetraminx-solver-QSJNGET5.js","node_modules/cubing/src/cubing/vendor/xyzzy/master_tetraminx-solver.js"],"sourcesContent":["\"use strict\";\nimport {\n  randomUIntBelowFactory\n} from \"./chunk-43SBQEWR.js\";\nimport \"./chunk-MGJA5U5O.js\";\n\n// src/cubing/vendor/xyzzy/master_tetraminx-solver.js\nfunction factorial(n) {\n  if (n < 2)\n    return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++)\n    f *= i;\n  return f;\n}\nfunction identity_permutation(n) {\n  let a = Array(n);\n  for (let i = 0; i < n; i++) {\n    a[i] = i;\n  }\n  return a;\n}\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = ind / f | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i])\n        perm[j]++;\n      else\n        parity ^= 1;\n    }\n  }\n  if (parity === 1)\n    [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\nvar [evenpermutation12_to_index, index_to_evenpermutation12] = (() => {\n  let index_in_set_bits = new Int8Array(4096 * 12);\n  let look_up_set_bits = new Int8Array(4096 * 12);\n  for (let i = 0; i < 4096; i++) {\n    for (let j = 0, counter = 0; j < 12; j++) {\n      if ((i >>> j & 1) === 0) {\n        continue;\n      }\n      index_in_set_bits[j << 12 | i] = counter;\n      look_up_set_bits[counter << 12 | i] = j;\n      counter++;\n    }\n  }\n  function evenpermutation12_to_index2(perm) {\n    let unused = 4095;\n    let f = 19958400;\n    let ind = 0;\n    for (let i = 0; i < 10; i++) {\n      let v = perm[i];\n      ind += index_in_set_bits[unused | v << 12] * f;\n      unused &= ~(1 << v);\n      f /= 11 - i;\n    }\n    return ind;\n  }\n  function index_to_evenpermutation122(ind, perm) {\n    let unused = 4095;\n    let f = 19958400;\n    let parity = 0;\n    for (let i = 0; i < 10; i++) {\n      let a = ind / f | 0;\n      ind -= a * f;\n      parity ^= a & 1;\n      let v = look_up_set_bits[unused | a << 12];\n      perm[i] = v;\n      unused &= ~(1 << v);\n      f /= 11 - i;\n    }\n    perm[10] = look_up_set_bits[unused | parity << 12];\n    perm[11] = look_up_set_bits[unused | (parity ^ 1) << 12];\n    return perm;\n  }\n  return [evenpermutation12_to_index2, index_to_evenpermutation122];\n})();\nfunction compose(A, B) {\n  let C = [];\n  for (let i = 0; i < B.length; i++)\n    C[i] = A[B[i]];\n  return C;\n}\nfunction invert(perm) {\n  let inv = [];\n  for (let i = 0; i < perm.length; i++) {\n    inv[perm[i]] = i;\n  }\n  return inv;\n}\nfunction permutation_from_cycle(cycle, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++)\n    perm[i] = i;\n  for (let i = 0; i < cycle.length; i++) {\n    perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n  }\n  return perm;\n}\nfunction permutation_from_cycles(cycles, n) {\n  if (cycles.length === 0) {\n    return identity_permutation(n);\n  }\n  return cycles.map((cycle) => permutation_from_cycle(cycle, n)).reduce(compose);\n}\nfunction compose_state(state1, state2) {\n  let co = Array(4);\n  for (let i = 0; i < 4; i++) {\n    co[i] = (state1.co[i] + state2.co[i]) % 3;\n  }\n  let mp = compose(state1.mp, state2.mp);\n  let wp = compose(state1.wp, state2.wp);\n  let cp = compose(state1.cp, state2.cp);\n  return { co, mp, wp, cp };\n}\nvar solved = {\n  co: [0, 0, 0, 0],\n  mp: identity_permutation(12),\n  wp: identity_permutation(12),\n  cp: [0, 1, 2, 3]\n};\nvar move_U = {\n  co: [2, 0, 0, 0],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([1, 9, 11], 12),\n  cp: [0, 1, 2, 3]\n};\nvar move_L = {\n  co: [0, 2, 0, 0],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([0, 7, 2], 12),\n  cp: [0, 1, 2, 3]\n};\nvar move_R = {\n  co: [0, 0, 2, 0],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([3, 6, 10], 12),\n  cp: [0, 1, 2, 3]\n};\nvar move_B = {\n  co: [0, 0, 0, 2],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([4, 8, 5], 12),\n  cp: [0, 1, 2, 3]\n};\nvar move_Uw = {\n  co: [2, 0, 0, 0],\n  mp: permutation_from_cycles([\n    [1, 9, 11],\n    [7, 3, 5]\n  ], 12),\n  wp: permutation_from_cycles([\n    [1, 9, 11],\n    [7, 3, 5]\n  ], 12),\n  cp: [0, 2, 3, 1]\n};\nvar move_Lw = {\n  co: [0, 2, 0, 0],\n  mp: permutation_from_cycles([\n    [0, 7, 2],\n    [6, 1, 8]\n  ], 12),\n  wp: permutation_from_cycles([\n    [0, 7, 2],\n    [6, 1, 8]\n  ], 12),\n  cp: [3, 1, 0, 2]\n};\nvar move_Rw = {\n  co: [0, 0, 2, 0],\n  mp: permutation_from_cycles([\n    [3, 6, 10],\n    [9, 0, 4]\n  ], 12),\n  wp: permutation_from_cycles([\n    [3, 6, 10],\n    [9, 0, 4]\n  ], 12),\n  cp: [1, 3, 2, 0]\n};\nvar move_Bw = {\n  co: [0, 0, 0, 2],\n  mp: permutation_from_cycles([\n    [4, 8, 5],\n    [10, 2, 11]\n  ], 12),\n  wp: permutation_from_cycles([\n    [4, 8, 5],\n    [10, 2, 11]\n  ], 12),\n  cp: [2, 0, 1, 3]\n};\nvar moves = [\n  move_Uw,\n  move_Lw,\n  move_Rw,\n  move_Bw,\n  move_U,\n  move_L,\n  move_R,\n  move_B\n];\nvar move_names = [\"u\", \"l\", \"r\", \"b\", \"U\", \"L\", \"R\", \"B\"];\nvar N_MOVES = 8;\nvar N_MOVES_PHASE2 = 4;\nfunction moves_commute(i, j) {\n  if (i >= 4 && j >= 4) {\n    return true;\n  }\n  if (i < 4 && j < 4) {\n    return i === j;\n  }\n  return (i ^ j) === 4;\n}\nfunction stringify_move_sequence(move_sequence) {\n  let suffixes = [\"0\", \"\", \"'\"];\n  let s = move_sequence.map(([m, r]) => move_names[m] + suffixes[r]);\n  return s.join(\" \");\n}\nfunction generate_random_state(randomUintBelow2) {\n  let co = Array(4);\n  for (let i = 0; i < 4; i++) {\n    co[i] = randomUintBelow2(3);\n  }\n  let mp = index_to_evenpermutation(randomUintBelow2(factorial(6) / 2), 6);\n  for (let i = 0, parity = 0; i < 6; i++) {\n    let eo = i === 5 ? parity : randomUintBelow2(2);\n    parity ^= eo;\n    mp[i] += eo * 6;\n    mp[i + 6] = (mp[i] + 6) % 12;\n  }\n  let wp = index_to_evenpermutation(randomUintBelow2(factorial(12) / 2), 12);\n  let cp = index_to_evenpermutation(randomUintBelow2(factorial(4) / 2), 4);\n  return { co, mp, wp, cp };\n}\nfunction generate_random_state_scramble(randomUintBelow2) {\n  return solve(generate_random_state(randomUintBelow2));\n}\nfunction generate_scramble_sequence(randomUintBelow2, tips = true, obfuscate_tips = false) {\n  let scramble_string = stringify_move_sequence(generate_random_state_scramble(randomUintBelow2));\n  if (!tips) {\n    return scramble_string;\n  }\n  let tip_names = [\"u\", \"l\", \"r\", \"b\"];\n  let suffixes = [\"0\", \"\", \"'\"];\n  if (!obfuscate_tips) {\n    for (let i = 0; i < 4; i++) {\n      let x = randomUintBelow2(3);\n      if (x !== 0) {\n        scramble_string += \" \" + tip_names[i] + suffixes[x];\n      }\n    }\n    return scramble_string.trim();\n  }\n  let amount = [], amount_pre = [], amount_post = [];\n  for (let i = 0; i < 4; i++) {\n    amount[i] = randomUintBelow2(3);\n    amount_pre[i] = randomUintBelow2(3);\n    amount_post[i] = (amount[i] - amount_pre[i] + 3) % 3;\n  }\n  let weight = (arr) => arr.filter((x) => x !== 0).length;\n  while (!(weight(amount_pre) >= 1 && weight(amount_post) >= 1 && weight(amount_pre) + weight(amount_post) >= 4)) {\n    for (let i = 0; i < 4; i++) {\n      amount_pre[i] = randomUintBelow2(3);\n      amount_post[i] = (amount[i] - amount_pre[i] + 3) % 3;\n    }\n  }\n  let prepend = amount_pre.map((x, i) => x !== 0 ? tip_names[i] + suffixes[x] + \" \" : \"\").join(\"\");\n  let append = amount_post.map((x, i) => x !== 0 ? \" \" + tip_names[i] + suffixes[x] : \"\").join(\"\");\n  return prepend + scramble_string + append;\n}\nfunction solve(state) {\n  let phase1_indices = index_phase1(state);\n  let phase2_mtables = [\n    generate_phase2_permutation_mtable(),\n    generate_phase2_orientation_mtable()\n  ];\n  let phase2_ptables = [\n    generate_phase2_permutation_ptable(),\n    generate_phase2_orientation_ptable()\n  ];\n  let phase1gen = phase1_ida_solve_gen(phase1_indices);\n  let best = void 0;\n  let intermediate_states = /* @__PURE__ */ new Set();\n  let start_time = performance.now();\n  for (let i = 0; i < 22; i++) {\n    let { value: sol1, done } = phase1gen.next();\n    let new_state = state;\n    for (let [m, r] of sol1) {\n      for (let i2 = 0; i2 < r; i2++)\n        new_state = compose_state(new_state, moves[m]);\n    }\n    let stringified_state = JSON.stringify(new_state);\n    if (intermediate_states.has(stringified_state)) {\n      continue;\n    } else\n      intermediate_states.add(stringified_state);\n    let phase2_indices = index_phase2(new_state);\n    let moves_left = best ? best.length - sol1.length - 1 : 999999;\n    let sol2 = ida_solve_gen(phase2_indices, phase2_mtables, phase2_ptables, moves_left).next().value;\n    if (sol2 === void 0) {\n      continue;\n    }\n    if (best === void 0 || best.length > sol1.length + sol2.length) {\n      best = sol1.concat(sol2);\n    }\n    if (performance.now() - start_time > 300)\n      break;\n  }\n  return best;\n}\nfunction determine_V_coset(p) {\n  return p[3 ^ p.indexOf(3)];\n}\nfunction index_phase1(state) {\n  let w = compose(invert(state.mp), state.wp);\n  let c = (state.co.reduce((x, y) => x + y) - determine_V_coset(state.cp) + 3) % 3;\n  return [0, 1, 2, 3, 4, 5].map((i) => i + 6 * w.indexOf(i) + 72 * w.indexOf(i + 6) + 864 * c);\n}\nvar phase1_permtable_m = [];\nvar phase1_permtable_minv = [];\nvar phase1_permtable_w = [];\nvar phase1_permtable_winv = [];\nfor (let i = 0; i < N_MOVES; i++) {\n  let move = moves[i];\n  phase1_permtable_m[i] = move.mp;\n  phase1_permtable_minv[i] = invert(move.mp);\n  phase1_permtable_w[i] = move.wp;\n  phase1_permtable_winv[i] = invert(move.wp);\n}\nvar phase1_c_update = [0, 0, 0, 0, 2, 2, 2, 2];\nvar phase1_score_ptable = [\n  [\n    14,\n    -1,\n    -1,\n    11,\n    11,\n    10,\n    9,\n    8,\n    8,\n    7,\n    7,\n    6,\n    4,\n    5,\n    5,\n    3,\n    4,\n    4,\n    2,\n    3,\n    4,\n    3,\n    -1,\n    -1,\n    0\n  ],\n  [\n    13,\n    -1,\n    -1,\n    11,\n    10,\n    10,\n    9,\n    8,\n    8,\n    7,\n    7,\n    6,\n    4,\n    5,\n    5,\n    3,\n    4,\n    4,\n    2,\n    3,\n    3,\n    1,\n    -1,\n    -1,\n    6\n  ]\n];\nvar phase1_score_ptable_condensed = new Int8Array(55);\nfor (let i = 0; i < 25; i++) {\n  phase1_score_ptable_condensed[i] = phase1_score_ptable[0][i];\n  phase1_score_ptable_condensed[i + 30] = phase1_score_ptable[1][i];\n}\nvar phase1_coord_to_score = new Int8Array(6 * 12 * 12 * 3);\nfor (let i = 0; i < 6; i++)\n  for (let j = 0; j < 12; j++)\n    for (let k = 0; k < 12; k++) {\n      let index = i + 6 * j + 72 * k;\n      let score = 2;\n      if (j === i) {\n        score++;\n      } else if (j === (i + 6) % 12) {\n        score--;\n      }\n      if (k === (i + 6) % 12) {\n        score++;\n      } else if (k === i) {\n        score--;\n      }\n      phase1_coord_to_score[index] = score;\n      phase1_coord_to_score[index + 6 * 12 * 12] = phase1_coord_to_score[index + 2 * 6 * 12 * 12] = score + 5;\n    }\nfunction* phase1_ida_solve_gen(coords) {\n  let bound = 0;\n  let mtable = generate_phase1_pairingc_mtable();\n  let ptable = generate_phase1_pairing2c_ptable();\n  while (true) {\n    yield* phase1_ida_search_gen(...coords, mtable, ptable, bound, -1);\n    bound++;\n  }\n}\nfunction* phase1_ida_search_gen(a, b, c, d, e, f, mtable, ptable, bound, last) {\n  let nmoves = N_MOVES;\n  let score = phase1_coord_to_score[a] + phase1_coord_to_score[b] + phase1_coord_to_score[c] + phase1_coord_to_score[d] + phase1_coord_to_score[e] + phase1_coord_to_score[f];\n  let heuristic = Math.max(ptable[a % 864 + b * 864], ptable[c % 864 + b * 864], ptable[e % 864 + b * 864], ptable[a % 864 + d * 864], ptable[c % 864 + d * 864], ptable[e % 864 + d * 864], ptable[a % 864 + f * 864], ptable[c % 864 + f * 864], ptable[e % 864 + f * 864], ptable[a % 864 + c * 864], ptable[a % 864 + e * 864], ptable[c % 864 + e * 864], ptable[b % 864 + d * 864], ptable[b % 864 + f * 864], ptable[d % 864 + f * 864], phase1_score_ptable_condensed[score]);\n  if (heuristic > bound)\n    return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1)\n    return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last)\n      continue;\n    if (m < last && moves_commute(m, last))\n      continue;\n    let A = a, B = b, C = c, D = d, E = e, F = f;\n    for (let r = 1; r <= 2; r++) {\n      A = mtable[A][m];\n      B = mtable[B][m];\n      C = mtable[C][m];\n      D = mtable[D][m];\n      E = mtable[E][m];\n      F = mtable[F][m];\n      let subpath_gen = phase1_ida_search_gen(A, B, C, D, E, F, mtable, ptable, bound - 1, m);\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done)\n          break;\n        yield [[m, r]].concat(subpath);\n      }\n    }\n  }\n}\nfunction index_phase2(state) {\n  let edges = state.mp;\n  let ep = evenpermutation_to_index(edges.slice(0, 6).map((x) => x % 6));\n  let eo = edges.slice(0, 5).map((x, i) => (x >= 6) * 2 ** i).reduce((x, y) => x + y);\n  let co = state.co.map((x, i) => x * 3 ** i).reduce((x, y) => x + y);\n  let cloc = state.cp.indexOf(0);\n  return [ep + 360 * cloc, eo + 32 * co];\n}\nvar tables = {};\nfunction generate_phase1_pairing_mtable() {\n  if (tables.phase1pm) {\n    return tables.phase1pm;\n  }\n  let mtable = Array(6 * 12 * 12).fill().map(() => Array(N_MOVES).fill(-1));\n  for (let midge = 0; midge < 6; midge++) {\n    for (let wingl = 0; wingl < 12; wingl++) {\n      for (let wingh = 0; wingh < 12; wingh++) {\n        if (wingl === wingh) {\n          continue;\n        }\n        let index = midge + 6 * wingl + 72 * wingh;\n        for (let m = 0; m < N_MOVES; m++) {\n          let new_midge = phase1_permtable_minv[m][midge];\n          let new_wingl = phase1_permtable_winv[m][wingl];\n          let new_wingh = phase1_permtable_winv[m][wingh];\n          if (new_midge < 6) {\n            mtable[index][m] = new_midge + 6 * new_wingl + 72 * new_wingh;\n          } else {\n            mtable[index][m] = new_midge - 6 + 6 * new_wingh + 72 * new_wingl;\n          }\n        }\n      }\n    }\n  }\n  return tables.phase1pm = mtable;\n}\nfunction generate_phase1_pairingc_mtable() {\n  if (tables.phase1pcm) {\n    return tables.phase1pcm;\n  }\n  let mtable_pairing = generate_phase1_pairing_mtable();\n  let mtable = Array(mtable_pairing.length * 3).fill().map(() => Array(N_MOVES).fill(-1));\n  for (let index = 0; index < mtable_pairing.length; index++) {\n    for (let m = 0; m < N_MOVES; m++) {\n      let new_index = mtable_pairing[index][m];\n      mtable[index][m] = new_index + 6 * 12 * 12 * phase1_c_update[m];\n      mtable[index + 6 * 12 * 12][m] = new_index + 6 * 12 * 12 * ((phase1_c_update[m] + 1) % 3);\n      mtable[index + 2 * 6 * 12 * 12][m] = new_index + 6 * 12 * 12 * ((phase1_c_update[m] + 2) % 3);\n    }\n  }\n  return tables.phase1pcm = mtable;\n}\nfunction generate_phase1_pairing2c_ptable() {\n  if (tables.phase1p2cp) {\n    return tables.phase1p2cp;\n  }\n  let mtable_noc = generate_phase1_pairing_mtable();\n  let mtable = generate_phase1_pairingc_mtable();\n  let ptable = new Int8Array((6 * 12 * 12) ** 2 * 3);\n  ptable.fill(-1);\n  let g = [0, 1, 2, 3, 4, 5].map((x) => x + 6 * x + 72 * (x + 6));\n  for (let i = 0; i < 6; i++)\n    for (let j = 0; j < 6; j++) {\n      if (i === j)\n        continue;\n      ptable[g[i] + 864 * g[j]] = 0;\n    }\n  let dist = 0;\n  while (true) {\n    let changed = false;\n    for (let index = 0; index < ptable.length; index++) {\n      if (ptable[index] !== dist) {\n        continue;\n      }\n      let index0 = index % 864, index1 = Math.floor(index / 864);\n      for (let m = 0; m < N_MOVES; m++) {\n        let new_index0 = index0, new_index1 = index1;\n        for (let r = 1; r <= 2; r++) {\n          new_index0 = mtable_noc[new_index0][m];\n          new_index1 = mtable[new_index1][m];\n          let new_index = new_index0 + 864 * new_index1;\n          if (ptable[new_index] === -1) {\n            changed = true;\n            ptable[new_index] = dist + 1;\n          }\n        }\n      }\n    }\n    if (!changed) {\n      break;\n    }\n    dist++;\n  }\n  return tables.phase1p2cp = ptable;\n}\nfunction generate_phase2_permutation_mtable() {\n  if (tables.phase2pm) {\n    return tables.phase2pm;\n  }\n  let mtable = Array(1440).fill().map(() => Array(N_MOVES_PHASE2));\n  for (let ep = 0; ep < 360; ep++) {\n    let perm = index_to_evenpermutation(ep, 6);\n    for (let i = 0; i < 6; i++) {\n      perm[i + 6] = perm[i] + 6;\n    }\n    for (let m = 0; m < N_MOVES_PHASE2; m++) {\n      let new_perm = compose(perm, moves[m].mp);\n      let new_ep = evenpermutation_to_index(new_perm.slice(0, 6).map((x) => x % 6));\n      for (let new_cloc = 0; new_cloc < 4; new_cloc++) {\n        let cloc = moves[m].cp[new_cloc];\n        mtable[ep + 360 * cloc][m] = new_ep + 360 * new_cloc;\n      }\n    }\n  }\n  return tables.phase2pm = mtable;\n}\nfunction generate_phase2_orientation_mtable() {\n  if (tables.phase2om) {\n    return tables.phase2om;\n  }\n  let mtable = Array(32 * 81).fill().map(() => Array(N_MOVES_PHASE2));\n  for (let eo = 0; eo < 32; eo++) {\n    let eo_array = [0, 1, 2, 3, 4].map((i) => eo >> i & 1);\n    eo_array[5] = eo_array.reduce((x, y) => x ^ y);\n    let perm = [];\n    for (let i = 0; i < 6; i++) {\n      perm[i] = i + 6 * eo_array[i];\n      perm[i + 6] = i + 6 * (eo_array[i] ^ 1);\n    }\n    for (let co = 0; co < 81; co++) {\n      let co_array = [0, 1, 2, 3].map((i) => Math.floor(co / 3 ** i) % 3);\n      for (let m = 0; m < N_MOVES_PHASE2; m++) {\n        let new_perm = compose(perm, moves[m].mp);\n        let new_eo_array = new_perm.slice(0, 5).map((x) => +(x >= 6));\n        let new_eo = 0;\n        for (let i = 0; i < 5; i++) {\n          new_eo += new_eo_array[i] << i;\n        }\n        let new_co_array = co_array.map((x, i) => (x + moves[m].co[i]) % 3);\n        let new_co = 0;\n        for (let i = 0; i < 4; i++) {\n          new_co += new_co_array[i] * 3 ** i;\n        }\n        mtable[eo + 32 * co][m] = new_eo + 32 * new_co;\n      }\n    }\n  }\n  return tables.phase2om = mtable;\n}\nfunction generate_phase2_permutation_ptable() {\n  if (tables.phase2pp) {\n    return tables.phase2pp;\n  }\n  return tables.phase2pp = bfs(generate_phase2_permutation_mtable(), [0]);\n}\nfunction generate_phase2_orientation_ptable() {\n  if (tables.phase2op) {\n    return tables.phase2op;\n  }\n  return tables.phase2op = bfs(generate_phase2_orientation_mtable(), [0]);\n}\nfunction bfs(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  let queue = goal_states.slice(), new_queue = [];\n  let depth = 0;\n  while (queue.length > 0) {\n    new_queue.length = 0;\n    for (let state of queue) {\n      if (ptable[state] !== -1)\n        continue;\n      ptable[state] = depth;\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        while (new_state != state) {\n          new_queue.push(new_state);\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    [queue, new_queue] = [new_queue, queue];\n    depth += 1;\n  }\n  return ptable;\n}\nfunction* ida_solve_gen(indices, mtables, ptables, moves_left) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= moves_left) {\n    yield* ida_search_gen(indices, mtables, ptables, bound, -1);\n    bound++;\n  }\n}\nfunction* ida_search_gen(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound)\n    return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1)\n    return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last)\n      continue;\n    if (m < last && moves_commute(m, last))\n      continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = ida_search_gen(new_indices, mtables, ptables, bound - 1, m);\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done)\n          break;\n        yield [[m, r]].concat(subpath);\n      }\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n}\nvar randomUintBelow = randomUIntBelowFactory();\nasync function randomMasterTetraminxScrambleString() {\n  return generate_scramble_sequence(await randomUintBelow, false);\n}\n\"use strict\";\nexport {\n  randomMasterTetraminxScrambleString\n};\n//# sourceMappingURL=master_tetraminx-solver-QSJNGET5.js.map\n","/* eslint-disable */\n/* master pyraminx scramble generator */\n// From https://gist.github.com/torchlight/9a5c53da09d8e090756a228f4b5f3471\n// Added to `cubing.js` under the GPL license by permission from the author (@torchlight/xyzzy).\n\n\"use strict\";\n\nimport { randomUIntBelowFactory } from \"../random-uint-below\";\n\nfunction counter(A) {\n  let counts = [];\n  for (let a of A) counts[a] = (counts[a] || 0) + 1;\n  return counts;\n}\n\n/* Combinatoric functions */\n\nfunction factorial(n) {\n  if (n < 2) return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++) f *= i;\n  return f;\n}\n\nfunction identity_permutation(n) {\n  let a = Array(n);\n  for (let i = 0; i < n; i++) {\n    a[i] = i;\n  }\n  return a;\n}\n\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    // invariant: f == factorial(n)\n    // also, perm stores meaningful values up to perm[n]\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\n\nfunction index_to_permutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1);\n  for (let i = 0; i < n; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      perm[j] += +(perm[j] >= perm[i]);\n    }\n  }\n  return perm;\n}\n\nfunction permutation_parity(A) {\n  let n = A.length;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i; j < n; j++) {\n      if (A[i] > A[j]) parity ^= 1;\n    }\n  }\n  return parity;\n}\n\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i]) perm[j]++;\n      else parity ^= 1;\n    }\n  }\n  if (parity === 1) [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\n\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\n\nlet [evenpermutation12_to_index, index_to_evenpermutation12] = (() => {\n  let index_in_set_bits = new Int8Array(4096 * 12);\n  let look_up_set_bits = new Int8Array(4096 * 12);\n  for (let i = 0; i < 4096; i++) {\n    for (let j = 0, counter = 0; j < 12; j++) {\n      if (((i >>> j) & 1) === 0) {\n        continue;\n      }\n      index_in_set_bits[(j << 12) | i] = counter;\n      look_up_set_bits[(counter << 12) | i] = j;\n      counter++;\n    }\n  }\n\n  function evenpermutation12_to_index(perm) {\n    let unused = 0xfff; // track which values in 0..11 haven't been used so far\n    let f = 19958400; // = 11!/2\n    let ind = 0;\n    for (let i = 0; i < 10; i++) {\n      let v = perm[i];\n      ind += index_in_set_bits[unused | (v << 12)] * f;\n      unused &= ~(1 << v);\n      f /= 11 - i;\n    }\n    return ind;\n  }\n\n  function index_to_evenpermutation12(ind, perm) {\n    let unused = 0xfff;\n    let f = 19958400; // = 11!/2\n    let parity = 0;\n    for (let i = 0; i < 10; i++) {\n      let a = (ind / f) | 0;\n      ind -= a * f;\n      parity ^= a & 1;\n      let v = look_up_set_bits[unused | (a << 12)];\n      perm[i] = v;\n      unused &= ~(1 << v);\n      f /= 11 - i;\n    }\n    // the last two elements are uniquely determined by the other ten\n    perm[10] = look_up_set_bits[unused | (parity << 12)];\n    perm[11] = look_up_set_bits[unused | ((parity ^ 1) << 12)];\n    return perm;\n  }\n\n  // these functions could be significantly faster with SWAR, but we can't SWAR here without 64-bit\n  // bitwise ops. :<\n\n  return [evenpermutation12_to_index, index_to_evenpermutation12];\n})();\n\nfunction compose(A, B) {\n  let C = [];\n  for (let i = 0; i < B.length; i++) C[i] = A[B[i]];\n  return C;\n}\n\nfunction double_compose(A, B, C) {\n  let D = [];\n  for (let i = 0; i < C.length; i++) {\n    D[i] = A[B[C[i]]];\n  }\n  return D;\n}\n\nfunction invert(perm) {\n  let inv = [];\n  for (let i = 0; i < perm.length; i++) {\n    inv[perm[i]] = i;\n  }\n  return inv;\n}\n\nfunction permutation_from_cycle(cycle, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++) perm[i] = i;\n  for (let i = 0; i < cycle.length; i++) {\n    perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n  }\n  return perm;\n}\n\nfunction permutation_from_cycles(cycles, n) {\n  if (cycles.length === 0) {\n    return identity_permutation(n);\n  }\n  return cycles\n    .map((cycle) => permutation_from_cycle(cycle, n))\n    .reduce(compose);\n  // not very efficient, but this function is only called during init so it's fine\n}\n\n/* puzzle-specific stuff */\n\n/*\nWe will (mostly) ignore the trivial tips here. When we say \"single-layer\", we mean one layer\n*excluding* the tip, so it's really two layers on the physical puzzle; likewise, \"double-layer\"\nmeans three layers on the physical puzzle. Hopefully this won't be too confusing.\n\nTips (\"zero-layer\" moves?) are written with a single lowercase letter: u, l, r, b.\nSingle-layer moves are written with a single uppercase letter: U, L, R, B.\nDouble-layer moves are written with a single uppercase letter and a w suffix: Uw, Lw, Rw, Bw.\n\nThe master pyraminx has four types of pieces:\n- 4 corners (same as pyraminx); three orientations each (no permutation).\n- 6 midges (same as pyraminx); even permutation, two orientations each, sum(orientations)%2 = 0.\n- 12 wings; even permutation (no orientation).\n- 4 centres; even permutation (no visible orientation).\n\nThe total number of states is (3^4) * (6!/2 * 2^5) * (12!/2) * (4!/2) = 2 681 795 837 952 000.\n\nThis is small enough that an optimal solver is feasible *if* we can use large pruning tables, but\nif we want to keep init times short, a two-phase algorithm would be much better. Here, we will use a\ntwo-phase reduction algorithm: the first phase reduces to a Halpern-Meier Pyramid / Jing's pyraminx,\nand the second phase just solves that (using only double-layer moves).\n\nSome ~group theory~ flexing: the alternating group A_4 (acting on the centres) has a copy of the\nKlein four-group V as a normal subgroup of index 3. We can name the cosets (other than V itself) as\nthe cw coset if the elements are a clockwise 3-cycle (as viewed from a corner) and the ccw coset if\nthe elements are an anticlockwise 3-cycle. On the H-M pyra, (the name of) the V-coset of the centres\nis exactly the sum of the orientations of the corners mod 3; this follows from V being a normal\nsubgroup of A_4.\n\n---\n\nIn the first phase, we:\n(i) do edge pairing (12!/2 ~ 2.4e8);\n(ii) ensure the V-coset of the centres matches the corner orientations (3).\n\nRelevant coordinates:\nlocations of a midge and its matching wings + centre stuff ((6*12*11) * 3 = 2376)\n\nPruning table:\n- forming two tredges + centre stuff ((6*5*12*11*10*9) * 3 = 1069200)\n- counting solved wings versus flipped wings + centre stuff (21 * 2 = 42)\n\nThe first pruning table takes around a quarter of a second to generate, which is kinda slow, but it\ncan't be helped. We check all fifteen possible pairs. (Checking only three pairs is enough, but has\nvery poor worst-case performance.)\n\nThe second pruning table takes literally an hour to generate, but it's also small so we just hard-\ncode all of its values instead of computing it on initialisation. Using this table kills off worst-\ncase behaviour on \"bad\" scrambles, but doesn't do a lot on \"median\" scrambles.\n\n---\n\nIn the second phase, we solve the puzzle like a H-M pyra.\n\nRelevant coordinates:\n(i) edge permutation, location of yellow centre (6!/2 * 4 = 1440)\n(ii) edge orientation, corner orientation (2^5 * 3^4 = 2592)\n\nCorner orientation uniquely determines the V-coset of the centre permutation, and since V acts\nsharply transitively on the centres, knowing where the yellow centre is uniquely determines which\nelement of that V-coset is the centre permutation.\n\n---\n\nConsiderations for generating scrambles:\n\nTip scrambling: the standard pyraminx scramblers just put the tips at the end of the scramble. This\nis *really bad* when we're doing the scrambles by hand and then immediately solving afterwards.\nIdeally, the scramble sequence shouldn't reveal any obvious information about the scramble.\n\nLike 333 and a few other puzzles, the states of a master pyra have a group structure, and so we can\ntake inverses. Once we have generated a random state, we can return either the inverse of its\nsolution, or the solution of its inverse. Since inversion preserves uniformity, we could just as\nwell just directly return a solution of a random state.\n\n---\n\n(ASCII nets modified from TNoodle's source code comments)\n\ncorners:\n\n*           ____  ____                      ____  ____\n*         /\\    /\\    /\\                  /\\    /\\    /\\\n*        /3 \\  /  \\  /0 \\       U        /0 \\  /  \\  /3 \\\n*       /____\\/____\\/____\\     ____     /____\\/____\\/____\\\n*       \\    /\\    /\\    /   /\\    /\\   \\    /\\    /\\    /\n*        \\  /  \\  /  \\  /   /  \\0 /  \\   \\  /  \\  /  \\  /\n*         \\/____\\/____\\/   /____\\/____\\   \\/____\\/____\\/\n*          \\    /\\    /   /\\    /\\    /\\   \\    /\\    /\n*           \\  /1 \\  /   /  \\  /  \\  /  \\   \\  /2 \\  /\n*            \\/____\\/   /____\\/____\\/____\\   \\/____\\/\n*                       \\    /\\    /\\    /\n*                        \\1 /  \\  /  \\2 /\n*                    L    \\/____\\/____\\/    R\n*\n*                           ____  ____\n*                         /\\    /\\    /\\\n*                        /1 \\  /  \\  /2 \\\n*                       /____\\/____\\/____\\\n*                       \\    /\\    /\\    /\n*                        \\  /  \\  /  \\  /\n*                         \\/____\\/____\\/\n*                          \\    /\\    /\n*                           \\  /3 \\  /\n*                            \\/____\\/\n*\n*                               B\n\nmidges:\n\n*           ____  ____                      ____  ____\n*         /\\    /\\    /\\                  /\\    /\\    /\\\n*        /  \\  /11\\  /  \\       U        /  \\  /5 \\  /  \\\n*       /____\\/____\\/____\\     ____     /____\\/____\\/____\\\n*       \\    /\\    /\\    /   /\\    /\\   \\    /\\    /\\    /\n*        \\  /8 \\  /7 \\  /   /  \\  /  \\   \\  /9 \\  /10\\  /\n*         \\/____\\/____\\/   /____\\/____\\   \\/____\\/____\\/\n*          \\    /\\    /   /\\    /\\    /\\   \\    /\\    /\n*           \\  /  \\  /   /  \\1 /  \\3 /  \\   \\  /  \\  /\n*            \\/____\\/   /____\\/____\\/____\\   \\/____\\/\n*                       \\    /\\    /\\    /\n*                        \\  /  \\0 /  \\  /\n*                    L    \\/____\\/____\\/    R\n*\n*                           ____  ____\n*                         /\\    /\\    /\\\n*                        /  \\  /6 \\  /  \\\n*                       /____\\/____\\/____\\\n*                       \\    /\\    /\\    /\n*                        \\  /2 \\  /4 \\  /\n*                         \\/____\\/____\\/\n*                          \\    /\\    /\n*                           \\  /  \\  /\n*                            \\/____\\/\n*\n*                               B\n\nwings:\n\n*           ____  ____                      ____  ____\n*         /\\    /\\    /\\                  /\\    /\\    /\\\n*        /  \\5 /  \\11/  \\       U        /  \\11/  \\5 /  \\\n*       /____\\/____\\/____\\     ____     /____\\/____\\/____\\\n*       \\    /\\    /\\    /   /\\    /\\   \\    /\\    /\\    /\n*        \\8 /  \\  /  \\1 /   /1 \\  /9 \\   \\9 /  \\  /  \\4 /\n*         \\/____\\/____\\/   /____\\/____\\   \\/____\\/____\\/\n*          \\    /\\    /   /\\    /\\    /\\   \\    /\\    /\n*           \\2 /  \\7 /   /7 \\  /  \\  /3 \\   \\3 /  \\10/\n*            \\/____\\/   /____\\/____\\/____\\   \\/____\\/\n*                       \\    /\\    /\\    /\n*                        \\  /0 \\  /6 \\  /\n*                    L    \\/____\\/____\\/    R\n*\n*                           ____  ____\n*                         /\\    /\\    /\\\n*                        /  \\0 /  \\6 /  \\\n*                       /____\\/____\\/____\\\n*                       \\    /\\    /\\    /\n*                        \\2 /  \\  /  \\10/\n*                         \\/____\\/____\\/\n*                          \\    /\\    /\n*                           \\8 /  \\4 /\n*                            \\/____\\/\n*\n*                               B\n\ncentres:\n\n*           ____  ____                      ____  ____\n*         /\\    /\\    /\\                  /\\    /\\    /\\\n*        /  \\  /  \\  /  \\       U        /  \\  /  \\  /  \\\n*       /____\\/____\\/____\\     ____     /____\\/____\\/____\\\n*       \\    /\\    /\\    /   /\\    /\\   \\    /\\    /\\    /\n*        \\  /  \\2 /  \\  /   /  \\  /  \\   \\  /  \\1 /  \\  /\n*         \\/____\\/____\\/   /____\\/____\\   \\/____\\/____\\/\n*          \\    /\\    /   /\\    /\\    /\\   \\    /\\    /\n*           \\  /  \\  /   /  \\  /3 \\  /  \\   \\  /  \\  /\n*            \\/____\\/   /____\\/____\\/____\\   \\/____\\/\n*                       \\    /\\    /\\    /\n*                        \\  /  \\  /  \\  /\n*                    L    \\/____\\/____\\/    R\n*\n*                           ____  ____\n*                         /\\    /\\    /\\\n*                        /  \\  /  \\  /  \\\n*                       /____\\/____\\/____\\\n*                       \\    /\\    /\\    /\n*                        \\  /  \\0 /  \\  /\n*                         \\/____\\/____\\/\n*                          \\    /\\    /\n*                           \\  /  \\  /\n*                            \\/____\\/\n*\n*                               B\n\n---\n\nfull state:\n{\n co: int[4]: corner orientation (ccw twist = 1, cw twist = 2),\n mp: int[12]: midge facelet permutation (this encodes orientation as well),\n wp: int[12]: wing permutation,\n cp: int[4]: centre permutation\n}\n\nphase 1 state:\nint[6]: locations of midge and matching wings + (CO - coset index) % 3\n\nphase 2 state:\n[\n int: edge permutation + yellow centre coordinate (0..1439),\n int: edge orientation + corner orientation coordinate (0..2591)\n]\n*/\n\nfunction compose_state(state1, state2) {\n  let co = Array(4);\n  for (let i = 0; i < 4; i++) {\n    co[i] = (state1.co[i] + state2.co[i]) % 3;\n  }\n  let mp = compose(state1.mp, state2.mp);\n  let wp = compose(state1.wp, state2.wp);\n  let cp = compose(state1.cp, state2.cp);\n  return { co: co, mp: mp, wp: wp, cp: cp };\n}\n\nfunction invert_state(state) {\n  let co = Array(4);\n  for (let i = 0; i < 4; i++) {\n    co[i] = (3 - state.co[i]) % 3;\n  }\n  let mp = invert(state.mp);\n  let wp = invert(state.wp);\n  let cp = invert(state.cp);\n  return { co: co, mp: mp, wp: wp, cp: cp };\n}\n\nlet solved = {\n  co: [0, 0, 0, 0],\n  mp: identity_permutation(12),\n  wp: identity_permutation(12),\n  cp: [0, 1, 2, 3],\n};\n\n// the single-layer moves don't affect midges (mp) or centres (cp)\nlet move_U = {\n  co: [2, 0, 0, 0],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([1, 9, 11], 12),\n  cp: [0, 1, 2, 3],\n};\nlet move_L = {\n  co: [0, 2, 0, 0],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([0, 7, 2], 12),\n  cp: [0, 1, 2, 3],\n};\nlet move_R = {\n  co: [0, 0, 2, 0],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([3, 6, 10], 12),\n  cp: [0, 1, 2, 3],\n};\nlet move_B = {\n  co: [0, 0, 0, 2],\n  mp: identity_permutation(12),\n  wp: permutation_from_cycle([4, 8, 5], 12),\n  cp: [0, 1, 2, 3],\n};\n\n// the double-layer moves affect everything, but permute the midges and wings identically\nlet move_Uw = {\n  co: [2, 0, 0, 0],\n  mp: permutation_from_cycles(\n    [\n      [1, 9, 11],\n      [7, 3, 5],\n    ],\n    12,\n  ),\n  wp: permutation_from_cycles(\n    [\n      [1, 9, 11],\n      [7, 3, 5],\n    ],\n    12,\n  ),\n  cp: [0, 2, 3, 1],\n};\nlet move_Lw = {\n  co: [0, 2, 0, 0],\n  mp: permutation_from_cycles(\n    [\n      [0, 7, 2],\n      [6, 1, 8],\n    ],\n    12,\n  ),\n  wp: permutation_from_cycles(\n    [\n      [0, 7, 2],\n      [6, 1, 8],\n    ],\n    12,\n  ),\n  cp: [3, 1, 0, 2],\n};\nlet move_Rw = {\n  co: [0, 0, 2, 0],\n  mp: permutation_from_cycles(\n    [\n      [3, 6, 10],\n      [9, 0, 4],\n    ],\n    12,\n  ),\n  wp: permutation_from_cycles(\n    [\n      [3, 6, 10],\n      [9, 0, 4],\n    ],\n    12,\n  ),\n  cp: [1, 3, 2, 0],\n};\nlet move_Bw = {\n  co: [0, 0, 0, 2],\n  mp: permutation_from_cycles(\n    [\n      [4, 8, 5],\n      [10, 2, 11],\n    ],\n    12,\n  ),\n  wp: permutation_from_cycles(\n    [\n      [4, 8, 5],\n      [10, 2, 11],\n    ],\n    12,\n  ),\n  cp: [2, 0, 1, 3],\n};\n\nlet moves = [\n  move_Uw,\n  move_Lw,\n  move_Rw,\n  move_Bw,\n  move_U,\n  move_L,\n  move_R,\n  move_B,\n];\nlet move_names = [\"u\", \"l\", \"r\", \"b\", \"U\", \"L\", \"R\", \"B\"];\nconst N_MOVES = 8; // number of moves\nconst N_MOVES_PHASE2 = 4; // number of moves for phase 2\n\nfunction moves_commute(i, j) {\n  // single-layer moves always commute with each other\n  if (i >= 4 && j >= 4) {\n    return true;\n  }\n  // double-layer moves commute iff they are equal\n  if (i < 4 && j < 4) {\n    return i === j;\n  }\n  // a single-layer and a double-layer move commute iff they're on the same axis\n  return (i ^ j) === 4;\n}\n\nfunction apply_move_sequence(state, move_sequence) {\n  for (let [m, r] of move_sequence) {\n    for (let i = 0; i < r; i++) state = compose_state(state, moves[m]);\n  }\n  return state;\n}\n\nfunction stringify_move_sequence(move_sequence) {\n  let suffixes = [\"0\", \"\", \"'\"];\n  let s = move_sequence.map(([m, r]) => move_names[m] + suffixes[r]);\n  return s.join(\" \");\n}\n\nfunction print_move_sequence(move_sequence) {\n  console.log(stringify_move_sequence(move_sequence));\n}\n\nfunction generate_random_state(randomUintBelow) {\n  // master pyra has no \"nontrivial\" restrictions, beyond the usual parity stuff\n  let co = Array(4);\n  for (let i = 0; i < 4; i++) {\n    co[i] = randomUintBelow(3);\n  }\n  let mp = index_to_evenpermutation(randomUintBelow(factorial(6) / 2), 6);\n  for (let i = 0, parity = 0; i < 6; i++) {\n    let eo = i === 5 ? parity : randomUintBelow(2);\n    parity ^= eo;\n    mp[i] += eo * 6;\n    mp[i + 6] = (mp[i] + 6) % 12;\n  }\n  let wp = index_to_evenpermutation(randomUintBelow(factorial(12) / 2), 12);\n  let cp = index_to_evenpermutation(randomUintBelow(factorial(4) / 2), 4);\n  return { co: co, mp: mp, wp: wp, cp: cp };\n}\n\nfunction generate_random_state_scramble(randomUintBelow) {\n  return solve(generate_random_state(randomUintBelow));\n}\n\nfunction generate_scramble_sequence(\n  randomUintBelow,\n  tips = true,\n  obfuscate_tips = false,\n) {\n  let scramble_string = stringify_move_sequence(\n    generate_random_state_scramble(randomUintBelow),\n  );\n  if (!tips) {\n    return scramble_string;\n  }\n  let tip_names = [\"u\", \"l\", \"r\", \"b\"];\n  let suffixes = [\"0\", \"\", \"'\"];\n  if (!obfuscate_tips) {\n    for (let i = 0; i < 4; i++) {\n      let x = randomUintBelow(3);\n      if (x !== 0) {\n        scramble_string += \" \" + tip_names[i] + suffixes[x];\n      }\n    }\n    return scramble_string.trim();\n  }\n  let amount = [],\n    amount_pre = [],\n    amount_post = [];\n  for (let i = 0; i < 4; i++) {\n    amount[i] = randomUintBelow(3);\n    amount_pre[i] = randomUintBelow(3);\n    amount_post[i] = (amount[i] - amount_pre[i] + 3) % 3;\n  }\n  let weight = (arr) => arr.filter((x) => x !== 0).length;\n  while (\n    !(\n      weight(amount_pre) >= 1 &&\n      weight(amount_post) >= 1 &&\n      weight(amount_pre) + weight(amount_post) >= 4\n    )\n  ) {\n    for (let i = 0; i < 4; i++) {\n      amount_pre[i] = randomUintBelow(3);\n      amount_post[i] = (amount[i] - amount_pre[i] + 3) % 3;\n    }\n  }\n  let prepend = amount_pre\n    .map((x, i) => (x !== 0 ? tip_names[i] + suffixes[x] + \" \" : \"\"))\n    .join(\"\");\n  let append = amount_post\n    .map((x, i) => (x !== 0 ? \" \" + tip_names[i] + suffixes[x] : \"\"))\n    .join(\"\");\n  return prepend + scramble_string + append;\n  // this technically has the extremely edge case of the original no-tip scramble being the\n  // trivial scramble and the resulting string will have a double space, but this is Very Rare\n}\n\nfunction solve(state) {\n  let phase1_indices = index_phase1(state);\n  let phase2_mtables = [\n    generate_phase2_permutation_mtable(),\n    generate_phase2_orientation_mtable(),\n  ];\n  let phase2_ptables = [\n    generate_phase2_permutation_ptable(),\n    generate_phase2_orientation_ptable(),\n  ];\n\n  let phase1gen = phase1_ida_solve_gen(phase1_indices);\n  let best = undefined;\n  let intermediate_states = new Set();\n  let start_time = performance.now();\n  for (let i = 0; i < 22; i++) {\n    let { value: sol1, done } = phase1gen.next();\n    let new_state = state;\n    for (let [m, r] of sol1) {\n      for (let i = 0; i < r; i++)\n        new_state = compose_state(new_state, moves[m]);\n    }\n    let stringified_state = JSON.stringify(new_state);\n    if (intermediate_states.has(stringified_state)) {\n      // console.log(\"skip\");\n      continue;\n    } else intermediate_states.add(stringified_state);\n    let phase2_indices = index_phase2(new_state);\n    //let sol2 = [];\n    let moves_left = best ? best.length - sol1.length - 1 : 999999;\n    let sol2 = ida_solve_gen(\n      phase2_indices,\n      phase2_mtables,\n      phase2_ptables,\n      moves_left,\n    ).next().value;\n    if (sol2 === undefined) {\n      // console.log(\"prune\");\n      continue;\n    }\n    // console.log(\n    //   `to ${stringified_state} in ${sol1.length} moves; total move count ${\n    //     sol1.length + sol2.length\n    //   }`,\n    // );\n    if (best === undefined || best.length > sol1.length + sol2.length) {\n      best = sol1.concat(sol2);\n    }\n    // bail if we've spent too much time\n    if (performance.now() - start_time > 300) break;\n  }\n  return best;\n}\n\nfunction determine_V_coset(p) {\n  // p: even permutation on 4 elements\n  // NOTE: the formula depends on the centre ordering and corner orientation conventions\n  // V itself is 0, ccw coset is 1, cw coset is 2.\n  return p[3 ^ p.indexOf(3)];\n}\n\nfunction index_phase1(state) {\n  let w = compose(invert(state.mp), state.wp);\n  let c =\n    (state.co.reduce((x, y) => x + y) - determine_V_coset(state.cp) + 3) % 3;\n  return [0, 1, 2, 3, 4, 5].map(\n    (i) => i + 6 * w.indexOf(i) + 72 * w.indexOf(i + 6) + 864 * c,\n  );\n}\n\nlet phase1_permtable_m = [],\n  phase1_permtable_minv = [];\nlet phase1_permtable_w = [],\n  phase1_permtable_winv = [];\nfor (let i = 0; i < N_MOVES; i++) {\n  let move = moves[i];\n  phase1_permtable_m[i] = move.mp;\n  phase1_permtable_minv[i] = invert(move.mp);\n  phase1_permtable_w[i] = move.wp;\n  phase1_permtable_winv[i] = invert(move.wp);\n}\nlet phase1_c_update = [0, 0, 0, 0, 2, 2, 2, 2];\n\n/* score = (# matching wings - # flipped wings) + 12\n(the +12 is to make it have range 0..24 rather than -12..12)\n\nthis is more effective than looking at # matching wings alone, or # flipped wings alone.\n\nstats for centre/corner solved:\njs> num_by_score\n[1, 0, 0, 320, 1350, 11328, 77280, 422400, 2016735, 7808000, 23467296, 50855040, 70181300, 50855040, 23467296, 7808000, 2016735, 422400, 77280, 11328, 1350, 320, 0, 0, 1]\njs> min_by_score\n[14, 9999, 9999, 11, 11, 10, 9, 8, 8, 7, 7, 6, 4, 5, 5, 3, 4, 4, 2, 3, 4, 3, 9999, 9999, 0]\njs> max_by_score\n[14, -9999, -9999, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 11, 10, 10, 10, 9, 8, 8, 5, -9999, -9999, 0]\njs> sum_by_score\n[14, 0, 0, 3856, 16458, 131856, 904280, 4885752, 23019405, 87454032, 256924344, 542481888, 725249936, 501317616, 218566356, 67825352, 16313334, 3116472, 509352, 63600, 7854, 1288, 0, 0, 0]\n\nstats for centre/corner unsolved:\njs> min_by_score\n[13, 9999, 9999, 11, 10, 10, 9, 8, 8, 7, 7, 6, 4, 5, 5, 3, 4, 4, 2, 3, 3, 1, 9999, 9999, 6]\njs> max_by_score\n[13, -9999, -9999, 13, 13, 13, 13, 13, 13, 13, 13, 12, 13, 12, 11, 11, 10, 9, 9, 8, 8, 6, -9999, -9999, 6]\njs> sum_by_score\n[13, 0, 0, 3792, 16026, 133344, 900726, 4870308, 23008797, 87434932, 256859772, 542586948, 725077315, 501101484, 218802804, 67943128, 16250601, 3110148, 509044, 65940, 7284, 1148, 0, 0, 6]\n\n*/\n\nlet phase1_score_ptable = [\n  //-12        -9  -8  -7 -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9         12\n  [\n    14, -1, -1, 11, 11, 10, 9, 8, 8, 7, 7, 6, 4, 5, 5, 3, 4, 4, 2, 3, 4, 3, -1,\n    -1, 0,\n  ],\n  [\n    13, -1, -1, 11, 10, 10, 9, 8, 8, 7, 7, 6, 4, 5, 5, 3, 4, 4, 2, 3, 3, 1, -1,\n    -1, 6,\n  ],\n];\nlet phase1_score_ptable_condensed = new Int8Array(55);\nfor (let i = 0; i < 25; i++) {\n  phase1_score_ptable_condensed[i] = phase1_score_ptable[0][i];\n  phase1_score_ptable_condensed[i + 30] = phase1_score_ptable[1][i];\n}\nlet phase1_coord_to_score = new Int8Array(6 * 12 * 12 * 3);\nfor (let i = 0; i < 6; i++)\n  for (let j = 0; j < 12; j++)\n    for (let k = 0; k < 12; k++) {\n      let index = i + 6 * j + 72 * k;\n      let score = 2;\n      if (j === i) {\n        score++;\n      } else if (j === (i + 6) % 12) {\n        score--;\n      }\n      if (k === (i + 6) % 12) {\n        score++;\n      } else if (k === i) {\n        score--;\n      }\n      phase1_coord_to_score[index] = score;\n      phase1_coord_to_score[index + 6 * 12 * 12] = phase1_coord_to_score[\n        index + 2 * 6 * 12 * 12\n      ] = score + 5;\n    }\n\nfunction phase1_benchmark() {\n  /* some 13-move phase 1 states*/\n  let phase1_test_states = [\n    [1836, 2551, 1922, 1947, 2440, 2063],\n    [1674, 1153, 1058, 1353, 1000, 1271],\n    [1764, 2497, 1904, 2001, 2242, 2087],\n    [582, 301, 566, 273, 40, 431],\n    [600, 217, 200, 477, 136, 431],\n    [60, 613, 98, 273, 214, 407],\n    [36, 265, 98, 777, 190, 431],\n    [1764, 1987, 2402, 1881, 2368, 2159],\n    [36, 277, 194, 129, 334, 431],\n    [1764, 1843, 1928, 2499, 2158, 2039],\n    [528, 721, 194, 429, 112, 275],\n    [840, 115, 182, 219, 346, 425],\n    [1752, 1831, 2498, 1989, 2416, 1943],\n    [324, 133, 554, 231, 58, 431],\n    [18, 331, 194, 495, 658, 431],\n    [1764, 1987, 1880, 2337, 2578, 2081],\n    [1776, 1855, 1934, 1989, 2050, 2231],\n    [396, 811, 194, 297, 712, 47],\n    [816, 115, 482, 273, 148, 425],\n    [972, 907, 1070, 1281, 1174, 1511],\n  ];\n  generate_phase1_pairing2c_ptable();\n  let start = performance.now();\n  for (let coords of phase1_test_states) {\n    phase1_ida_solve_gen(coords).next();\n  }\n  return performance.now() - start;\n}\n\nfunction* phase1_ida_solve_gen(coords) {\n  let bound = 0;\n  let mtable = generate_phase1_pairingc_mtable();\n  let ptable = generate_phase1_pairing2c_ptable();\n  while (true) {\n    yield* phase1_ida_search_gen(...coords, mtable, ptable, bound, -1);\n    bound++;\n  }\n}\n\nfunction* phase1_ida_search_gen(a, b, c, d, e, f, mtable, ptable, bound, last) {\n  let nmoves = N_MOVES; // = 8\n  let score =\n    phase1_coord_to_score[a] +\n    phase1_coord_to_score[b] +\n    phase1_coord_to_score[c] +\n    phase1_coord_to_score[d] +\n    phase1_coord_to_score[e] +\n    phase1_coord_to_score[f];\n  let heuristic = Math.max(\n    ptable[(a % 864) + b * 864],\n    ptable[(c % 864) + b * 864],\n    ptable[(e % 864) + b * 864],\n    ptable[(a % 864) + d * 864],\n    ptable[(c % 864) + d * 864],\n    ptable[(e % 864) + d * 864],\n    ptable[(a % 864) + f * 864],\n    ptable[(c % 864) + f * 864],\n    ptable[(e % 864) + f * 864],\n    ptable[(a % 864) + c * 864],\n    ptable[(a % 864) + e * 864],\n    ptable[(c % 864) + e * 864],\n    ptable[(b % 864) + d * 864],\n    ptable[(b % 864) + f * 864],\n    ptable[(d % 864) + f * 864],\n    phase1_score_ptable_condensed[score],\n  );\n  if (heuristic > bound) return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && moves_commute(m, last)) continue;\n    let A = a,\n      B = b,\n      C = c,\n      D = d,\n      E = e,\n      F = f;\n    for (let r = 1; r <= 2; r++) {\n      A = mtable[A][m];\n      B = mtable[B][m];\n      C = mtable[C][m];\n      D = mtable[D][m];\n      E = mtable[E][m];\n      F = mtable[F][m];\n      let subpath_gen = phase1_ida_search_gen(\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        mtable,\n        ptable,\n        bound - 1,\n        m,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n    }\n  }\n}\n\nfunction index_phase2(state) {\n  let edges = state.mp;\n  let ep = evenpermutation_to_index(edges.slice(0, 6).map((x) => x % 6));\n  let eo = edges\n    .slice(0, 5)\n    .map((x, i) => (x >= 6) * 2 ** i)\n    .reduce((x, y) => x + y);\n  let co = state.co.map((x, i) => x * 3 ** i).reduce((x, y) => x + y);\n  let cloc = state.cp.indexOf(0);\n  return [ep + 360 * cloc, eo + 32 * co];\n}\n\nlet tables = {};\n\nfunction generate_phase1_pairing_mtable() {\n  if (tables.phase1pm) {\n    return tables.phase1pm;\n  }\n  let mtable = Array(6 * 12 * 12)\n    .fill()\n    .map(() => Array(N_MOVES).fill(-1));\n  for (let midge = 0; midge < 6; midge++) {\n    for (let wingl = 0; wingl < 12; wingl++) {\n      for (let wingh = 0; wingh < 12; wingh++) {\n        if (wingl === wingh) {\n          continue;\n        }\n        let index = midge + 6 * wingl + 72 * wingh;\n        for (let m = 0; m < N_MOVES; m++) {\n          let new_midge = phase1_permtable_minv[m][midge];\n          let new_wingl = phase1_permtable_winv[m][wingl];\n          let new_wingh = phase1_permtable_winv[m][wingh];\n          if (new_midge < 6) {\n            mtable[index][m] = new_midge + 6 * new_wingl + 72 * new_wingh;\n          } else {\n            mtable[index][m] = new_midge - 6 + 6 * new_wingh + 72 * new_wingl;\n          }\n        }\n      }\n    }\n  }\n  return (tables.phase1pm = mtable);\n}\n\nfunction generate_phase1_pairingc_mtable() {\n  if (tables.phase1pcm) {\n    return tables.phase1pcm;\n  }\n  let mtable_pairing = generate_phase1_pairing_mtable();\n  let mtable = Array(mtable_pairing.length * 3)\n    .fill()\n    .map(() => Array(N_MOVES).fill(-1));\n  for (let index = 0; index < mtable_pairing.length; index++) {\n    for (let m = 0; m < N_MOVES; m++) {\n      let new_index = mtable_pairing[index][m];\n      mtable[index][m] = new_index + 6 * 12 * 12 * phase1_c_update[m];\n      mtable[index + 6 * 12 * 12][m] =\n        new_index + 6 * 12 * 12 * ((phase1_c_update[m] + 1) % 3);\n      mtable[index + 2 * 6 * 12 * 12][m] =\n        new_index + 6 * 12 * 12 * ((phase1_c_update[m] + 2) % 3);\n    }\n  }\n  return (tables.phase1pcm = mtable);\n}\n\nfunction generate_phase1_pairing2c_ptable() {\n  if (tables.phase1p2cp) {\n    return tables.phase1p2cp;\n  }\n  let mtable_noc = generate_phase1_pairing_mtable();\n  let mtable = generate_phase1_pairingc_mtable();\n  let ptable = new Int8Array((6 * 12 * 12) ** 2 * 3);\n  ptable.fill(-1);\n  let g = [0, 1, 2, 3, 4, 5].map((x) => x + 6 * x + 72 * (x + 6));\n  for (let i = 0; i < 6; i++)\n    for (let j = 0; j < 6; j++) {\n      if (i === j) continue;\n      ptable[g[i] + 864 * g[j]] = 0;\n    }\n  let dist = 0;\n  while (true) {\n    let changed = false;\n    for (let index = 0; index < ptable.length; index++) {\n      if (ptable[index] !== dist) {\n        continue;\n      }\n      let index0 = index % 864,\n        index1 = Math.floor(index / 864);\n      for (let m = 0; m < N_MOVES; m++) {\n        let new_index0 = index0,\n          new_index1 = index1;\n        for (let r = 1; r <= 2; r++) {\n          new_index0 = mtable_noc[new_index0][m];\n          new_index1 = mtable[new_index1][m];\n          let new_index = new_index0 + 864 * new_index1;\n          if (ptable[new_index] === -1) {\n            changed = true;\n            ptable[new_index] = dist + 1;\n          }\n        }\n      }\n    }\n    if (!changed) {\n      break;\n    }\n    dist++;\n  }\n  return (tables.phase1p2cp = ptable);\n}\n\nfunction generate_phase1_full_ptable() {\n  // extremely slow, do not use\n  if (tables.phase1p) {\n    return tables.phase1p;\n  }\n  const HALFFACT12 = factorial(12) / 2;\n  const SIZE = HALFFACT12 * 3;\n  let ptable = new Int8Array(SIZE).fill(-1);\n  ptable[0] = 0;\n  let dist = 0;\n  let perm = new Int8Array(12),\n    new_perm = new Int8Array(12);\n  while (true) {\n    let changed = false;\n    let count = 0;\n    for (let index = 0; index < SIZE; index++) {\n      if (ptable[index] !== dist) {\n        continue;\n      }\n      count++;\n      let cindex = index % 3;\n      let windex = (index - cindex) / 3;\n      index_to_evenpermutation12(windex, perm);\n      for (let m = 0; m < N_MOVES; m++) {\n        let move_m = phase1_permtable_m[m],\n          move_minv = phase1_permtable_minv[m];\n        let move_w = phase1_permtable_w[m],\n          move_winv = phase1_permtable_winv[m];\n        {\n          // clockwise move\n          let new_cindex = (cindex + phase1_c_update[m]) % 3;\n          for (let i = 0; i < 12; i++) {\n            new_perm[i] = move_minv[perm[move_w[i]]];\n          }\n          let new_windex = evenpermutation12_to_index(new_perm);\n          let new_index = new_cindex + 3 * new_windex;\n          if (ptable[new_index] === -1) {\n            changed = true;\n            ptable[new_index] = dist + 1;\n          }\n        }\n        {\n          // anticlockwise move\n          let new_cindex = (cindex + 3 - phase1_c_update[m]) % 3;\n          for (let i = 0; i < 12; i++) {\n            new_perm[i] = move_m[perm[move_winv[i]]];\n          }\n          let new_windex = evenpermutation12_to_index(new_perm);\n          let new_index = new_cindex + 3 * new_windex;\n          if (ptable[new_index] === -1) {\n            changed = true;\n            ptable[new_index] = dist + 1;\n          }\n        }\n      }\n    }\n    console.log(`${count} nodes at depth ${dist}`);\n    if (!changed) {\n      break;\n    }\n    dist++;\n  }\n  return (tables.phase1p = ptable);\n}\n\nfunction generate_phase2_permutation_mtable() {\n  if (tables.phase2pm) {\n    return tables.phase2pm;\n  }\n  let mtable = Array(1440)\n    .fill()\n    .map(() => Array(N_MOVES_PHASE2));\n  for (let ep = 0; ep < 360; ep++) {\n    let perm = index_to_evenpermutation(ep, 6);\n    // fill in the \"opposite\" values\n    for (let i = 0; i < 6; i++) {\n      perm[i + 6] = perm[i] + 6;\n    }\n    for (let m = 0; m < N_MOVES_PHASE2; m++) {\n      let new_perm = compose(perm, moves[m].mp);\n      let new_ep = evenpermutation_to_index(\n        new_perm.slice(0, 6).map((x) => x % 6),\n      );\n      for (let new_cloc = 0; new_cloc < 4; new_cloc++) {\n        let cloc = moves[m].cp[new_cloc];\n        mtable[ep + 360 * cloc][m] = new_ep + 360 * new_cloc;\n      }\n    }\n  }\n  return (tables.phase2pm = mtable);\n}\n\nfunction generate_phase2_orientation_mtable() {\n  if (tables.phase2om) {\n    return tables.phase2om;\n  }\n  let mtable = Array(32 * 81)\n    .fill()\n    .map(() => Array(N_MOVES_PHASE2));\n  for (let eo = 0; eo < 32; eo++) {\n    let eo_array = [0, 1, 2, 3, 4].map((i) => (eo >> i) & 1);\n    eo_array[5] = eo_array.reduce((x, y) => x ^ y);\n    let perm = [];\n    for (let i = 0; i < 6; i++) {\n      perm[i] = i + 6 * eo_array[i];\n      perm[i + 6] = i + 6 * (eo_array[i] ^ 1);\n    }\n    for (let co = 0; co < 81; co++) {\n      let co_array = [0, 1, 2, 3].map((i) => Math.floor(co / 3 ** i) % 3);\n      for (let m = 0; m < N_MOVES_PHASE2; m++) {\n        let new_perm = compose(perm, moves[m].mp);\n        let new_eo_array = new_perm.slice(0, 5).map((x) => +(x >= 6));\n        let new_eo = 0;\n        for (let i = 0; i < 5; i++) {\n          new_eo += new_eo_array[i] << i;\n        }\n        let new_co_array = co_array.map((x, i) => (x + moves[m].co[i]) % 3);\n        let new_co = 0;\n        for (let i = 0; i < 4; i++) {\n          new_co += new_co_array[i] * 3 ** i;\n        }\n        mtable[eo + 32 * co][m] = new_eo + 32 * new_co;\n      }\n    }\n  }\n  return (tables.phase2om = mtable);\n}\n\nfunction generate_phase2_permutation_ptable() {\n  if (tables.phase2pp) {\n    return tables.phase2pp;\n  }\n  return (tables.phase2pp = bfs(generate_phase2_permutation_mtable(), [0]));\n}\n\nfunction generate_phase2_orientation_ptable() {\n  if (tables.phase2op) {\n    return tables.phase2op;\n  }\n  return (tables.phase2op = bfs(generate_phase2_orientation_mtable(), [0]));\n}\n\nfunction bfs(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  let queue = goal_states.slice(),\n    new_queue = [];\n  let depth = 0;\n  while (queue.length > 0) {\n    new_queue.length = 0;\n    for (let state of queue) {\n      if (ptable[state] !== -1) continue;\n      ptable[state] = depth;\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        while (new_state != state) {\n          new_queue.push(new_state);\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    [queue, new_queue] = [new_queue, queue];\n    depth += 1;\n  }\n  return ptable;\n}\n\nfunction* ida_solve_gen(indices, mtables, ptables, moves_left) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (bound <= moves_left) {\n    yield* ida_search_gen(indices, mtables, ptables, bound, -1);\n    bound++;\n  }\n}\n\nfunction* ida_search_gen(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0) {\n    yield [];\n    return;\n  }\n  if (heuristic === 0 && bound === 1) return;\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    if (m < last && moves_commute(m, last)) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath_gen = ida_search_gen(\n        new_indices,\n        mtables,\n        ptables,\n        bound - 1,\n        m,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n}\n\nconst randomUintBelow = randomUIntBelowFactory();\nexport async function randomMasterTetraminxScrambleString() {\n  return generate_scramble_sequence(await randomUintBelow, false);\n}\n"],"names":[],"version":3,"file":"master_tetraminx-solver-QSJNGET5.2399ec73.js.map"}